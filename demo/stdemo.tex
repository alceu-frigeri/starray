%%%==============================================================================
%% Copyright 2023-present by Alceu Frigeri
%%
%% This work may be distributed and/or modified under the conditions of
%%
%% * The [LaTeX Project Public License](http://www.latex-project.org/lppl.txt),
%%   version 1.3c (or later), and/or
%% * The [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.html),
%%   version 3 (or later)
%%
%% This work has the LPPL maintenance status *maintained*.
%%
%% The Current Maintainer of this work is Alceu Frigeri
%%
%% This is version {1.9b} {2025/02/14} 
%%
%% The list of files that compose this work can be found in the README.md file at
%% https://ctan.org/pkg/starray
%%
%%%==============================================================================
\NeedsTeXFormat{LaTeX2e}[2023/11/01]
\documentclass[10pt]{article}
\RequirePackage[verbose,a4paper,marginparwidth=27.5mm,top=2.5cm,bottom=1.5cm,hmargin={40mm,20mm},marginparsep=2.5mm,columnsep=10mm,asymmetric]{geometry}
%\RequirePackage[verbose,a4paper,marginparwidth=27.5mm,top=2.5cm,bottom=1.5cm,hmargin={45mm,25mm},marginparsep=2.5mm,columnsep=10mm,asymmetric]{geometry}
\usepackage{codedescribe}
\usepackage{stdemo}
\RequirePackage[inline]{enumitem}
\SetEnumitemKey{miditemsep}{parsep=0ex,itemsep=0.4ex}

\RequirePackage{amsfonts} % for those check marks: \checkmark and \square

\RequirePackage[hidelinks,hypertexnames=false]{hyperref}
\begin{document}

\tstitle{
  author={Alceu Frigeri\footnote{\tsverb{https://github.com/alceu-frigeri/starray/tree/main/demo}}},
  date={\tsdate},
  title={The stdemo Package\break for starray version \PkgInfo{starray}{version}}
  }
 
 
\begin{tsabstract}
  As an example of how a package writer could use the \tsobj[pkg]{starray} package, this documents a demo package, \tsobj[pkg]{stdemo}, which defines a set of commands aiming to describe a set of activities and students' work associated with them. An example of how to use these commands is presented at the end of this document.
\end{tsabstract}

\tableofcontents

\section{Introduction}
The purpose of this is to create an example of how to use a \tsobj[pkg]{starray} in a complete setup. That for, this demo has a few parts:
\begin{enumerate*}
  \item A companion package \tsobj[pkg]{stdemo.sty},
  \item this document which documents not just the user level functions/commands, but also how the the companion package was created, with  a small example (at the end) of how to use it.
\end{enumerate*}
\begin{tsremark}
  About the version number, since this is ``part'' of \tsobj[pkg]{starray}, and to keep tracking simple, the same version number (from \tsobj[pkg]{starray}) will be used.
\end{tsremark}

\setnewcodekey{stdemo}{codeprefix={},resultprefix={},letter={@,_},
  keywd2={
    starray_new,starray_def_from_keyval,
    starray_new_term,starray_get_unique_id,starray_gset_prop,starray_set_prop,
    starray_get_cnt,starray_term_syntax,starray_set_iter,
    starray_set_iter_from_hash,starray_get_prop,starray_gset_from_keyval,
    starray_iterate_over,starray_parsed_get_prop,starray_parsed_get_cnt
    },
  texcs2={
    NewActivity,ActivitySet,ActivitySetCoord,ActivitySetCoordTitle,
    ActivitySelect,Activity,ActivityCoord,
    ActivityCalendarIterate,
    ActivitySetNewEvent,ActivitySetEventDay,
    student,advisor,coadvisor,examiner,reviewer,advisorinfo,coadvisorinfo,examinerinfo,
    examinergrades,studentgrade,studentselect,studentReviewerSelect,
    studentAdvCase,studentCoadvCase,studentReviewerSetCase,studentCase,
    studentiterate,studentadvisoriterate,
    emptytermifnone, emptyfields,studentaddtolist,studentlistsort,
    listemptytermsifnone,studentlistiterate,checklist
    },
  emph={
    __stdemo_set_prof_info,__stdemo_set_prof,__stdemo_emptyterm_if_none,__stdemo_student_emptyfields_if_none,
    __stdemo_seq_sort,__stdemo_emptyfields,
  },
  }

\begin{codestore}[activity-def]
\starray_new:n {activity}
\starray_def_from_keyval:nn {activity} {
    name = Activity's~ name ,
    acronym = ACRO ,
    coord . struct =  {
        name = Coordinator's~ name,
        title = Coordinator's~ title ,
      } ,
    calendar . struct = {
        date = {-day-} ,
        week = {-week-} ,
        event = {-event-} ,
      } ,
    chkID = ,        %%% 'unique ID' for checklists
    chkmarked = ,    %%% This shall be a prop list of   marked itens
    chkunmarked = ,  %%% This shall be a prop list of unmarked itens
    chkref = ,       %%% This shall be a prop list of ref      itens
  }
\end{codestore}


\begin{codestore}[student-def]
\starray_new:n {student}
\starray_def_from_keyval:nn {student}
 {
  self = , %% this shall be self hash (if any)
  first = ,
  last = ,
  name = \rule{\l__stdemo_name_rule_dim}{.1pt} ,
  ID    = \rule{\l__stdemo_ID_rule_dim}{.1pt} , 
  email = \rule{\l__stdemo_email_rule_dim}{.1pt} ,
  worktitle = \rule{\l__stdemo_worktitle_rule_dim}{.1pt} ,
  remarks = ,
  board-local = {~local/place~} ,
  board-date   = {~date~} ,
  board-time  = {~time~} ,
  grade = 0 ,
  flag-graded = \c_false_bool , %%% IF grade already calculated (or defined)
  flag-approved = \c_false_bool ,
  flag-coadvisor = \c_false_bool ,
  advisor . struct = {
    first = ,
    last =  ,
    name = \rule{\l__stdemo_name_rule_dim}{.1pt},
    institution = \rule{\l__stdemo_name_rule_dim}{.1pt},
    title = \rule{\l__stdemo_title_rule_dim}{.1pt} ,
    email = \rule{\l__stdemo_email_rule_dim}{.1pt} ,
  } ,
  coadvisor . struct = {
    first = ,
    last =  ,
    name = \rule{\l__stdemo_name_rule_dim}{.1pt},
    institution = \rule{\l__stdemo_name_rule_dim}{.1pt},
    title = \rule{\l__stdemo_title_rule_dim}{.1pt} ,
    email = \rule{\l__stdemo_email_rule_dim}{.1pt} ,
  } ,
  reviewer . struct = {
    first = ,
    last =  ,
    name = \rule{\l__stdemo_name_rule_dim}{.1pt},
    institution = \rule{\l__stdemo_name_rule_dim}{.1pt},
    title = \rule{\l__stdemo_title_rule_dim}{.1pt} ,
    email = \rule{\l__stdemo_email_rule_dim}{.1pt} ,
    pointA = ,
    pointB = ,
    pointC = ,
    pointD = ,
    grade = 0 ,
    flag-set = \c_false_bool , 
  } ,
 }
\end{codestore}

\begin{codestore}[DataRecovery]
\NewDocumentCommand{\eDataSet}{m}{
  \starray_term_syntax:n{#1}
}  
\end{codestore}

\begin{codestore}[DataRecovery]
\cs_new:Npn \eDataField #1 
  { \starray_parsed_get_prop:n{#1} }
\end{codestore}


\begin{codestore}[DataRecovery]
\NewDocumentCommand{\DataField }{mm}{
  \starray_get_prop:nn{#1}{#2}
}  
\end{codestore}

\begin{codestore}[DataRecovery]
\NewDocumentCommand{\DataGet}{mmm}{
  \starray_get_prop:nnN{#1}{#2}{#3}
}  
\end{codestore}

\begin{codestore}[ActCmd:New]
\NewDocumentCommand{\NewActivity}{mmm} {
    \starray_new_term:nn  {activity}{#1}
    \starray_set_prop:nnn {activity}{acronym}{#2}
    \starray_set_prop:nnn {activity}{name}{#3}
    \starray_new_term:nn  {activity.coord}{}
    \starray_get_unique_id:nN {activity} \l__stdemo_tmpID_tl
    \starray_gset_prop:nnV {activity}{chkID} \l__stdemo_tmpID_tl
    \prop_new_linked:c {l__stdemo_ \l__stdemo_tmpID_tl _chkmarked_prop}
    \prop_new_linked:c {l__stdemo_ \l__stdemo_tmpID_tl _chkunmarked_prop}
    \prop_new_linked:c {l__stdemo_ \l__stdemo_tmpID_tl _chkref_prop}
}
\end{codestore}

\begin{codestore}[ActCmd:SetCoord]
\NewDocumentCommand{\ActivitySetCoord}{O{}mm}{
  \tl_if_blank:nTF {#1}
    {
      \starray_gset_prop:nnn {activity.coord}{title}{#2}
      \starray_gset_prop:nnn {activity.coord}{name}{#3}
    }
    {
      \starray_gset_prop:nnn {activity[#1].coord}{title}{#2}
      \starray_gset_prop:nnn {activity[#1].coord}{name}{#3}
    }
}
\end{codestore}


\begin{codestore}[ActCmd:SetEvent] 
\NewDocumentCommand{\ActivitySetNewEvent}{O{}mm}{
  \tl_if_blank:nTF {#1}
    {
      \starray_new_term:nn {activity.calendar}{#2}
      \starray_gset_prop:nnn {activity.calendar}{event}{#3}
    }
    {
      \starray_new_term:nn {activity[#1].calendar}{#2}
      \starray_gset_prop:nnn {activity[#1].calendar}{event}{#3}
    }
}
\end{codestore}

\begin{codestore}[ActCmd:SetEvent] 
\NewDocumentCommand{\ActivitySetEventDay}{O{}mmm}{
  \tl_if_blank:nTF {#1}
    {
      \starray_gset_from_keyval:nn {activity.calendar[#2]}
        {
            date = {#3} ,
            week = {#4} ,
        }
    }
    {
      \starray_gset_from_keyval:nn {activity[#1].calendar[#2]}
        {
            date = {#3} ,
            week = {#4} ,
        }
    }
}
\end{codestore}

\begin{codestore}[ActCmd:CheckList]
\NewDocumentCommand{\checkdef}{mmm}{
    \starray_get_prop:nnN {activity}{chkID}\l__stdemo_chkID_tl
    \prop_gput:cnn {l__stdemo_ \l__stdemo_chkID_tl _chkmarked_prop} {#1}{\__stdemo_checkedbox:~\ #3}
    \prop_gput:cnn {l__stdemo_ \l__stdemo_chkID_tl _chkunmarked_prop} {#1}{\__stdemo_uncheckedbox:~\ #3}
    \prop_gput:cnn {l__stdemo_ \l__stdemo_chkID_tl _chkref_prop} {#2}{#1}
  }
\end{codestore}

\begin{codestore}[ActCmd:CheckList]
\NewDocumentCommand{\checklist}{O{}m}{
    \tl_if_blank:nF {#1}
      {  \starray_set_iter_from_hash:nn {activity}{#1}  }
  
    \starray_get_prop:nnN {student}  {chkID} \l__stdemo_chkIDa_tl
    \starray_get_prop:nnN {activity} {chkID} \l__stdemo_chkIDb_tl
  
    \clist_map_inline:nn {#2}
      {
        \prop_get:cnNT {l__stdemo_ \l__stdemo_chkIDb_tl _chkref_prop} {##1} \l__stdemo_checkref_tl
          {
            \prop_get:ceN {l__stdemo_ \l__stdemo_chkIDb_tl _chkmarked_prop} {\l__stdemo_checkref_tl} \l__stdemo_checkB_tl
            \prop_gput:cee {l__stdemo_ \l__stdemo_chkIDa_tl _checklist_prop} {\l__stdemo_checkref_tl} {\l__stdemo_checkB_tl}
          }
      }
  }
\end{codestore}


\begin{codestore}[ActCmd:CheckList]
\NewDocumentCommand{\StudentCheckListTable}{mm}
  {
    \starray_get_prop:nnN {student}  {chkID} \l__stdemo_chkIDa_tl
    \starray_get_prop:nnN {activity} {chkID} \l__stdemo_chkIDb_tl
%    \tl_show:N \l__stdemo_chkIDa_tl
%    \tl_show:N \l__stdemo_chkIDb_tl
    {
      \prop_map_inline:cn {l__stdemo_ \l__stdemo_chkIDa_tl _checklist_prop}
        { \prop_put:cnn {l__stdemo_ \l__stdemo_chkIDb_tl _chkunmarked_prop} {##1}{##2}  }  
    
      \tl_gclear:N \l__stdemo_table_tl
      \clist_map_inline:nn {#1}    
        { 
          \tl_gclear:N \l_tmpa_tl    
          \clist_map_inline:nn {#2}
            {       
             \tl_gset:Nn \l__stdemo_tmpx_tl {##1####1} 
             \prop_get:ceNTF {l__stdemo_ \l__stdemo_chkIDb_tl _chkunmarked_prop} {\l__stdemo_tmpx_tl} \l__stdemo_tmpy_tl
               {\tl_gput_right:Ne \l__stdemo_table_tl {\l_tmpa_tl~ \l__stdemo_tmpy_tl}}
               {\tl_gput_right:Ne \l__stdemo_table_tl {\l_tmpa_tl~ }}
             \tl_gset:Nn \l_tmpa_tl {~&~}
            }
          \tl_gput_right:Nn \l__stdemo_table_tl {\\*}
        }
      }
      \l__stdemo_table_tl   
  }
\end{codestore}


\begin{codestore}[ActCmd:Select]
\NewDocumentCommand{\ActivitySelect}{m}
  { 
    \starray_set_iter_from_hash:nn {activity}{#1} 
  }
\end{codestore}


\begin{codestore}[ActCmd:CalIterate]
\NewDocumentCommand{\ActivityCalendarIterate}{m}{
    \starray_iterate_over:nn{activity.calendar}{#1}
}
\end{codestore}

\begin{codestore}[student:New]
\NewDocumentCommand{\student}{O{}mmmm}{%
  \tl_if_blank:nTF {#1}
    {\starray_new_term:nn {student}{}}
    {\starray_new_term:nn {student}{#1}}
  \starray_gset_from_keyval:nn {student}
    {
      self  = {#1} ,
      first = {#3} ,
      last = {#2} ,
      name = {#3~ #2} ,
      ID   = {#4} ,
      email   = {\tl_to_str:n{#5}} 
    }

  \starray_get_unique_id:nNTF {student}\l__stdemo_tmpID_tl
    {}
    {}
  \starray_gset_prop:nnV {student}{chkID} \l__stdemo_tmpID_tl
  \prop_new:c {l__stdemo_ \l__stdemo_tmpID_tl _checklist_prop}
}%
\end{codestore}

\begin{codestore}[student:New]
\NewDocumentCommand{\studentremark}{m}{
  \starray_gset_prop:nnn {student}{remarks}{#1}
}
\end{codestore}

\begin{codestore}[student:New]
\NewDocumentCommand{\worktitle}{m}{%%
  \starray_gset_prop:nnn {student}{worktitle}{#1}
}
\end{codestore}

\begin{codestore}[student:NewAdv]
\NewDocumentCommand{\advisor}{O{}mm}{%%
  \starray_new_term:nn {student.advisor}{}
  \__stdemo_set_prof:nnnn {advisor}{#1}{#2}{#3}
}
\end{codestore}


\begin{codestore}[student:NewAdv]
\NewDocumentCommand{\coadvisor}{O{}mm}{%%
  \starray_new_term:nn {student.coadvisor}{}
  \starray_gset_prop:nnn {student}{flag-coadvisor}{\c_true_bool}
  \__stdemo_set_prof:nnnn {coadvisor}{#1}{#2}{#3}
}
\end{codestore}



\begin{codestore}[student:NewAdv]
\NewDocumentCommand{\examiner}{O{}mm}{%%
  \starray_new_term:nn {student.reviewer}{}
  \starray_gset_prop:nnn {student.reviewer}{flag-set}{\c_true_bool}
  \__stdemo_set_prof:nnnn {reviewer}{#1}{#2}{#3}
}%
\end{codestore}

\begin{codestore}[student:NewAdv]
\cs_new_protected:Npn \__stdemo_set_prof:nnnn #1#2#3#4 
  {
    \tl_if_blank:nTF {#2}
      {
        \starray_gset_from_keyval:nn {student.#1}
          {
            last = {#3} ,
            first = {#4} ,
            name = {#4~ #3} ,
          }
      }
      {
        \starray_gset_from_keyval:nn {student.#1}
          {
            last = {#3} ,
            first = {#4} ,
            name = {#2~ #4~ #3} ,
          }
      }
  }
\end{codestore}

\begin{codestore}[student:NewAdv]
\NewDocumentCommand{\advisorinfo}{mmm}{%%
  \__stdemo_set_prof_info:nnnn {advisor}{#1}{#2}{#3}
}%
\end{codestore}

\begin{codestore}[student:NewAdv]
\NewDocumentCommand{\coadvisorinfo}{mmm}{%%
  \__stdemo_set_prof_info:nnnn {coadvisor}{#1}{#2}{#3}
}%
\end{codestore}

\begin{codestore}[student:NewAdv]
\NewDocumentCommand{\examinerinfo}{mmm}{%%
  \__stdemo_set_prof_info:nnnn {reviewer}{#1}{#2}{#3}
}%
\end{codestore}


\begin{codestore}[student:NewAdv]
\cs_new_protected:Npn \__stdemo_set_prof_info:nnnn #1#2#3#4
  {
    \starray_gset_from_keyval:nn {student.#1}
      {
        institution = {#2} ,
        title = {#3} ,
        email = {\tl_to_str:n{#4}} ,
      }
  }
\end{codestore}




\begin{codestore}[student:grades]
\NewDocumentCommand{\examinergrades}{O{A}mmmm} {
  \tl_if_blank:nTF {#2}
    { \starray_gset_prop:nnn {student.reviewer}{grade}{0} }
    {
      \starray_gset_from_keyval:nn {student.reviewer}
        {
          pointA = #2 ,
          pointB = #3 ,
          pointC = #4 ,
          pointD = #5 ,
        }
      \str_case:nnF {#1}
        {
          {A} 
            {
              \starray_gset_prop:nne {student.reviewer}{grade}
                { \fp_eval:n{round((#2  + #3 + #4 + #5) / 4 , 2 , 1) } }    
            }
          {B} 
            {
              \starray_gset_prop:nne {student.reviewer}{grade}
                { \fp_eval:n{round((#2  + #3 + #4) / 3 , 2 , 1) } }    
            }
        }
        {
          \starray_gset_prop:nne {student.reviewer}{grade}
            { \fp_eval:n{round((#2  + #3 + #4 + #5) / 4 , 2 , 1) } }    
        }
      
    }
  }
\end{codestore}


\begin{codestore}[student:grades]
\NewDocumentCommand{\studentgrade}{O{A}m}
  { %assuming there are 3 of them...
    \starray_get_prop:nnN {student.reviewer[1]}{grade} \l__stdemo_A_tl
    \starray_get_prop:nnN {student.reviewer[2]}{grade} \l__stdemo_B_tl
    \starray_get_prop:nnN {student.reviewer[3]}{grade} \l__stdemo_C_tl
    \str_case:nnF {#1}
      {
        {A} 
          {
            \starray_gset_prop:nne {student}{grade}
              {
                \fp_eval:n{round((\l__stdemo_A_tl + \l__stdemo_B_tl + \l__stdemo_C_tl) / 3 , 2 , 1) }
              }    
          }
        {B} 
          {
            \starray_gset_prop:nne {student}{grade}
              {
                \fp_eval:n{round((\l__stdemo_A_tl + \l__stdemo_B_tl) / 2 , 2 , 1) }
              }    
          }
        {C} 
          {
            \starray_gset_prop:nne {student}{grade}
              {
                \fp_eval:n{round(3 / (1/\l__stdemo_A_tl + 1/\l__stdemo_B_tl + 1/\l__stdemo_C_tl) , 2 , 1) }
              }    
          }
      }
      {
        \starray_gset_prop:nne {student}{grade}
          {
            \fp_eval:n{round((\l__stdemo_A_tl + \l__stdemo_B_tl + \l__stdemo_C_tl) / 3 , 2 , 1) }
          }    
      }
    \starray_get_prop:nnN {student}{grade} \l__stdemo_tmp_fp
    \fp_compare:nNnTF {\l__stdemo_tmp_fp} < {#2}
      {
        \starray_gset_prop:nnn {student}{flag-approved}{\c_false_bool}
      }
      {
        \starray_gset_prop:nnn {student}{flag-approved}{\c_true_bool}
      }
    \starray_gset_prop:nnn {student}{flag-graded}{\c_true_bool}
  }
\end{codestore}


\begin{codestore}[student:select]
\NewDocumentCommand{\studentselect}{m} { 
    \starray_set_iter_from_hash:nn {student}{#1} 
  }
\end{codestore}

\begin{codestore}[student:select]
\NewDocumentCommand{\studentReviewerSelect}{m} {
    \starray_set_iter:nn {student.reviewer}{#1}
  }
\end{codestore}

\begin{codestore}[student:cases]
\NewDocumentCommand{\studentAdvCase}{mm} {
    \starray_term_syntax:n{student.advisor}
    \int_compare:nNnTF {\starray_parsed_get_cnt:} > {1}
      {#1}
      {#2}
  }
\end{codestore}

\begin{codestore}[student:cases]
\NewDocumentCommand{\studentCoadvCase}{+m+m} {
    \starray_term_syntax:n{student}
    \bool_if:nTF {\starray_parsed_get_prop:n{flag-coadvisor}}
      {#1}
      {#2}
  }
\end{codestore}

\begin{codestore}[student:cases]
\NewDocumentCommand{\studentReviewerSetCase}{mmm} {
    \starray_term_syntax:n{student.reviewer[#1]}
    \bool_if:nTF {\starray_parsed_get_prop:n{flag-set}}
      {#2}
      {#3}
}
\end{codestore}

\begin{codestore}[student:cases]
\NewDocumentCommand{\studentCase}{mm} {
    \starray_term_syntax:n{student}
    \bool_if:nTF{\starray_parsed_get_prop:n{flag-approved}}
      {#1}
      {#2}
}
\end{codestore}



\begin{codestore}[student:iter]
\NewDocumentCommand{\studentiterate}{+m} {
    \starray_iterate_over:nn{student}{#1}
}
\end{codestore}

\begin{codestore}[student:iter]
\NewDocumentCommand{\studentadvisoriterate}{+m} {
    \starray_iterate_over:nn{student.advisor}{#1}
}
\end{codestore}


\begin{codestore}[student:emptyterm]
\NewDocumentCommand{\emptytermifnone}{O{1}mO{}}
  {
    \__stdemo_emptyterm_if_none:nnn {#1}{#2}{#3}
  }

\cs_new_protected:Npn \__stdemo_emptyterm_if_none:nnn #1#2#3
  {
    \starray_get_cnt:nN {#2} \l_tmpa_int
    \int_while_do:nNnn {\l_tmpa_int} < {#1}
      { 
        \starray_new_term:nn {#2}{} 
        #3
        \starray_get_cnt:nN {#2} \l_tmpa_int
      }
  }
\end{codestore}


\begin{codestore}[student:emptyterm]
\NewDocumentCommand{\emptyfields}{} {
    \__stdemo_emptyfields:
  }


\cs_new_protected:Npn \__stdemo_emptyfields:
  {
    \starray_new_term:nn {student}{empty}
    \starray_new_term:nn {student.advisor}{}
    \starray_new_term:nn {student.coadvisor}{}
    \starray_new_term:nn {student.reviewer}{}
    \starray_new_term:nn {student.reviewer}{}
    \starray_new_term:nn {student.reviewer}{}
  }
\end{codestore}


\begin{codestore}[student:list]
\NewDocumentCommand{\studentaddtolist}{m}
  {
    \seq_if_exist:cF {l__stdemo_#1_list_seq}
      {
        \seq_new:c {l__stdemo_#1_list_seq}

        \bool_new:c {l__stdemo_#1_classified_bool}
      }
    \bool_set_false:c {l__stdemo_#1_classified_bool}  
    \starray_term_syntax:n {student}
    \seq_gput_right:ce {l__stdemo_#1_list_seq} {\starray_parsed_get_prop:n {self}}
  }
\end{codestore}

\begin{codestore}[student:list]
\NewDocumentCommand{\studentlistsort}{O{name}m}
  {
    \bool_set_true:c {l__stdemo_#1_classified_bool}
    \__stdemo_seq_sort:nn {#2}{#1} 
  }

\cs_new_protected:Npn \__stdemo_seq_sort:nn #1#2
  {
    \seq_gsort:cn {l__stdemo_#1_list_seq }
      {
        \starray_set_iter_from_hash:nn {student}{##1}
        \starray_get_prop:nnN {student}{#2} \l__stdemo_sortA_tl
        \starray_set_iter_from_hash:nn {student}{##2}
        \starray_get_prop:nnN {student}{#2} \l__stdemo_sortB_tl          
        \str_compare:eNeTF { \l__stdemo_sortA_tl } > { \l__stdemo_sortB_tl }
          { \sort_return_swapped: }
          { \sort_return_same: }
      }  
  }
\end{codestore}  

\begin{codestore}[student:list]
\NewDocumentCommand{\listemptytermsifnone}{m}
  {
   \seq_map_inline:cn {l__stdemo_#1_list_seq}
      {
        \starray_set_iter_from_hash:nn {student}{##1}
     
        \emptytermifnone{student.advisor}
        \emptytermifnone[3]{student.reviewer}
%        % those could be, instead
%        \__stdemo_emptyterm_if_none:nnn {1}{ student.advisor } {}
%        \__stdemo_emptyterm_if_none:nnn {3}{ student.reviewer } {}
      }       
  }
\end{codestore}



\begin{codestore}[student:list]
\NewDocumentCommand{\studentlistiterate}{m+m}
  {
    \bool_if:cF {l__stdemo_#1_classified_bool}
      { \studentlistsort{#1} }
    \listemptytermsifnone{#1}
    \seq_map_inline:cn {l__stdemo_#1_list_seq}
      {
        \starray_set_iter_from_hash:nn {student}{##1}
        #2
      }
  }
\end{codestore}



\begin{codestore}[ActivityUseDemo]
  \NewActivity{FinalWork I}
  \ActivitySet{Final Work I}{FW001}
  
  \NewActivity{FinalWork II}
  
  \NewActivity{InternShip B}
  \ActivitySet{Final Intership}{IN099}
  
  \ActivitySet[FinalWork II]{Final Work II}{FW002}
\end{codestore}


\begin{codestore}[ActivityUseDemo]
  \ActivitySetCoordTitle[FinalWork I]{Prof. }
  \ActivitySetCoord[FinalWork I]{Willian S.}
   
  \ActivitySetCoordTitle[FinalWork II]{Prof. }
  \ActivitySetCoord[FinalWork II]{James S.}

  \ActivitySetCoordTitle[InternShip B]{Dr. }
  \ActivitySetCoord[InternShip B]{Samuel J. }
  
\end{codestore}






\section{Data Model}\label{DataModel}
As an example, let's define two structures:
\begin{enumerate}
  \item ``Activities'' (like a term project, course project, etc.)  with associated 
elements: 
\begin{enumerate}
  \item name, acronym
  \item coordinator
  \item calendar events (presentation dates, exams...)
  \item a check list.
\end{enumerate}

  \item Students, with associated date:
\begin{enumerate}
  \item name, IDs, etc.
  \item advisor and (perhaps) co-advisor.
  \item reviewer(s).
  \item flags, etc.
\end{enumerate}
  
  
\end{enumerate}

\begin{tsremark}
As in any ``procedural language'', one is advised to  carefully design the data model, since this will shape the functions which will set and use said data.
\end{tsremark}

\begin{tsremark}
  Pay attention to the use of the tildes,  \~{} , since those definitions will be made, most likely, in an \tsobj[pkg]{expl3} code r√©gime, one has to remember that spaces are ignored, therefore, if needed, one has to explicitly use a tilde instead of a space.
\end{tsremark}


\subsection{Activity Set}\label{Activity:DataModel}
For the activities one could set an ``starray'' as follow:







\tscode*[stdemo]{activity-def}


Whereas, the ``coord'' sub-structure is for the activity's coordinator, whilst ``calendar'' shall (for instance) contains a list of calendar events, and, finally, the many ``chk* '' will be used for a ``check list''.

\begin{tsremark}
The ``chkID'' (and checklists). In many cases it's handy to have an unique identifier for a given structure. That can be obtained with \tsobj{\starray_get_unique_ID:nN}, and to avoid calling this function time and time again, one can just store that ID as a field for later use.
\end{tsremark}
\begin{tsremark}
  Could the Coordinator's name and title be a direct property (avoiding the ``coord'' sub-structure)? of course, that's a matter of choice on how to model it.
\end{tsremark}





\subsection{Student Set}\label{student:DataModel}
A student's structure might contain, besides student's name, work title, some flags, an advisor (and co-advisor, if needed), reviewer's list (with a provision for reviewer's grade, if needed).

Of course, one doesn't need to define a \tsobj[pkg]{starray} structure using \tsobj{\starray_def_from_keyval:nn}, but, as in this,  if the set of properties is known, it always makes for a cleaner definition.

\begin{tsremark}
  The fields/properties defaults can be anything, including usual \LaTeXe\  commands, like a \tsobj{\rule} which is handy, for instance, when generating forms, e.g., if the fields are all set, a form can be created with the proper values, otherwise, it will be  created with ``rules'' in place (no need to test if the properties were set).
\end{tsremark}

\tscode*[stdemo]{student-def}








\section{Auxiliary Functions}
Once the data layout is set (see \ref{DataModel}) the next step is to define a set of (document level) functions, so the data can be initialized and used by the end user.

\subsection{Generic Recovery Functions}\label{generic:datafield}

\begin{codedescribe}{\DataField,\DataGet}
  \begin{codesyntax}
    \tsmacro{\DataField}{starray,item}
    \tsmacro{\DataGet}{starray,item,store-var}
  \end{codesyntax}
\tsobj{\DataField} will recovery an item from any \tsobj[pkg]{starray}, for instance, \tsobj[marg]{starray} might be \tsobj[meta,sep=or]{activity,activity.coord,activity.calendar,student,student.advisor} etc. whilst \tsobj[marg]{item} might be any corresponding field. The \tsobj{\DataGet} will store said value in an auxiliary \tsobj[marg]{store-var}.
\begin{tsremark}[\color{red}Note:]
  None of those commands are expandable. In general it should be enough (for the end user) to just use \tsobj{\DataField}, but it might be necessary to use a temporary variable, \tsobj[marg]{store-var}, allowing  its use in an expandable context.
\end{tsremark}
\end{codedescribe}


\tscode*[stdemo]{DataRecovery}[3]
\tscode*[stdemo]{DataRecovery}[4]

\subsection{Activity's Functions}

One could define a single function to initialize all fields (using a key=val interface), but, in a more traditional approach  one can set two functions to start the initialization process \tsobj{\NewActivity,\ActivitySet}. 


\subsubsection{Creating and Setting an Activity's Data}

\begin{codedescribe}{\NewActivity}
\begin{codesyntax}
  \tsmacro{\NewActiviy}{act-ID,acronym,name}
\end{codesyntax}
\tsobj{\NewActivity} will create a new activity term, \tsobj[marg]{act-ID} will be it's identifier (hash).

\end{codedescribe}
\begin{tsremark}
  Every time a \tsobj[pkg]{starray} is instantiated, up to two hashes are created: a numerical one (starting at one) and an ``user defined one''. In the \tsobj{\NewActivity} function above, \tsobj[marg]{act-ID} is that hash, so that instance can be later referenced by it. Of course, it must be an unique ID/hash.
\end{tsremark}
\begin{tsremark}
  One thing to be noticed about \tsobj[pkg]{starrays}: every structure has an associated internal index (iterator). When you create a new instance, this iterator always points to the newly created one, therefore, sparing the use of an explicit index in the subsequent commands.
\end{tsremark}

\tscode*[stdemo]{ActCmd:New}[1]
%\tscode*[stdemo]{ActCmd:New}[2]

~

Similarly, one can define some functions to set the activity's coordinator. Of course, it's up to the package programmer to choose if one, two (or more) functions for this.

\begin{codedescribe}{\ActivitySetCoord}
\begin{codesyntax}
  \tsmacro{\ActivitySetCoord}[act-ID]{name,title}
\end{codesyntax}
The optional argument \tsobj[oarg]{act-ID} should refer to an already create activity, and, if not given, will use the current one.
\end{codedescribe}

\tscode*[stdemo]{ActCmd:SetCoord}[1]
%\tscode*[stdemo]{ActCmd:SetCoord}[2]


And the associated ``Calendar Events'', assuming there will be a fixed set of events (each semester/year), leaving the date to be set later on. 

\begin{codedescribe}{\ActivitySetNewEvent,\ActivitySetEventDay}
\begin{codesyntax}
  \tsmacro{\ActivitySetNewEvent}[act-ID]{event-ID,description}
  \tsmacro{\ActivitySetEventDay}[act-ID]{event-ID,date,week}
\end{codesyntax}
The optional argument \tsobj[oarg]{act-ID} refers to an already create activity, and, if not given, the current one will used. \tsobj[marg]{event-ID} can be any identifier. That way, the user can first define a set of events, and later on, set the associated dates.
\end{codedescribe}


\tscode*[stdemo]{ActCmd:SetEvent}[1]



\tscode*[stdemo]{ActCmd:SetEvent}[2]



\subsubsection{Check Lists}\label{Activity-checklist}

It's often desirable to have a ``check list''. What such list could entice is always up to debate, the idea behind the few next functions is to allow the end user to define which items such a list (as a matrix) might have.

\begin{codedescribe}{\checkdef}
\begin{codesyntax}
  \tsmacro{\checkdef}{chkID,chkPos,chktext}
\end{codesyntax}
  \tsobj[marg]{chkID} is just an ID to reference the check list item. \tsobj[marg]{chkPos} will relate the item to a position in a matrix (tabular environment, see \tsobj{\StudentCheckListTable}) and \tsobj[marg]{chktext} is the (assumed) short text.
  The command \tsobj{\checkdef} defines/create a new check item.
\end{codedescribe}
\begin{tsremark}
  In the implementation below, three property lists are created (based on the activity unique ID). Two of them with the \tsobj[marg]{chktext} marked and unmarked, and a third relating the \tsobj[marg]{chkID} a given position \tsobj[marg]{chkPos}.
\end{tsremark}



\tscode*[stdemo]{ActCmd:CheckList}[1]

\begin{codedescribe}{\checklist}
\begin{codesyntax}
  \tsmacro{\checklist}[act-ID]{chkID-list}
\end{codesyntax}
  This sets a list of \tsobj[marg]{chkID}s associated with the current student. Note that, since the checklist is based on an activity, the optional parameter allows to explicitly select one.
\end{codedescribe}
\begin{tsremark}
  In the implementation below, the property list, associated with the student unique ID, will use as keys the \tsobj[marg]{chkPost} from \tsobj{\checkdef} and as associated value the ones from the activity's marked property list.
\end{tsremark}

\tscode*[stdemo]{ActCmd:CheckList}[2]


\begin{codedescribe}{\StudentCheckListTable}
\begin{codesyntax}
  \tsmacro{\StudentCheckListTable}{L-list,C-list}
\end{codesyntax}
  This will produces a checklist matrix. Both \tsobj[marg]{L-list,C-list} shall be a comma list of ``lines'' and ``columns''. More specifically, each \tsobj[marg]{L-list} element will be compose with each \tsobj[marg]{C-list} element like ``$L_iC_j$'' which shall correspond to one of the \tsobj[marg]{chkPos} elements defined with \tsobj{\checkdef}.
\end{codedescribe}
\begin{tsremark}
  Better said, this will produces the inner part of a table, sans the table begin/end. Also note, in the code example below, that each table line is finished with a \tsobj[verb]{\\*}.
\end{tsremark}

\tscode*[stdemo]{ActCmd:CheckList}[3]



%\tsmergedcode*[stdemo]{{ActCmd:CheckList}[1-2]}

~

\subsubsection{Selecting an Activity}

\begin{codedescribe}{\ActivitySelect}
  \begin{codesyntax}
    \tsmacro{\ActivitySelect}{act-ID}
  \end{codesyntax}
  This will just select an activity, identified by \tsobj[marg]{act-ID} as the current one. So that, in the following commands, one can avoid the first, optional, argument.
\end{codedescribe}


\tscode*[stdemo]{ActCmd:Select}



\subsubsection{Iterating over the Calendar Data}

\begin{codedescribe}{\ActivityCalendarIterate}
  \begin{codesyntax}
    \tsmacro{\ActivityCalendarIterate}{code}
  \end{codesyntax}
  This is a helper function, based on \tsobj{\starray_iterate_over:nn}, so that the end user is free to construct an ``Event Calendar'' with the (activity's) stored data. The suggested pattern is: 
  \begin{enumerate*}
    \item Select an activity with \tsobj{\ActivitySelect}, then
    \item execute the code for each item stored in the activity's calendar list.
  \end{enumerate*}. The user is supposed to use (in \tsobj[marg]{code}) \tsobj[code,sep=or]{\DataField,\DataGet} to retrieve and use the calendar's data.
\end{codedescribe}

\tscode*[stdemo]{ActCmd:CalIterate}


\subsection{Student's Functions}

\subsubsection{Creating and Setting Student's Data}\label{student:new}

\begin{codedescribe}{\student,\studentremark,\worktitle}
  \begin{codesyntax}
    \tsmacro{\student}[student-hash]{last,first,ID,email}
    \tsmacro{\studentremark}{remark}
    \tsmacro{\worktitle}{work-title}
  \end{codesyntax}
  As always, there are many ways to achieve this. The \tsobj{\student} ``creates'' a new student entry, the (not so) optional parameter \tsobj[oarg]{student-hash} associates it with the given hash (otherwise one would have to keep track 'which index' correspond to a student). An auxiliary property list, for a checklist (see \ref{Activity-checklist} and \tsobj{\StudentCheckListTable} ), is created using  the student unique identifier, \tsobj{\starray_get_unique_id}.
\end{codedescribe}

\tscode*[stdemo]{student:New}[1]
\tscode*[stdemo]{student:New}[2]
\tscode*[stdemo]{student:New}[3]

\begin{codedescribe}{\advisor,\coadvisor,\examiner}
  \begin{codesyntax}
    \tsmacro{\advisor}[pre-nom]{last,first}
    \tsmacro{\coadvisor}[pre-nom]{last,first}
    \tsmacro{\examiner}[pre-nom]{last,first}
  \end{codesyntax}
  Those are just some auxiliary commands to set the advisor's/coadvisor's/examiner's name. The first optional parameter \tsobj[oarg]{pre-nom} can be used as a title. With each call of those, a new \tsobj[pkg]{starry} term is created for the current student.
\end{codedescribe}

\tscode*[stdemo]{student:NewAdv}[1]
\tscode*[stdemo]{student:NewAdv}[2]
\tscode*[stdemo]{student:NewAdv}[3]
\tscode*[stdemo]{student:NewAdv}[4]

\begin{codedescribe}{\advisorinfo,\coadvisorinfo,\examinerinfo}
  \begin{codesyntax}
    \tsmacro{\advisorinfo}{institute,title,email}
    \tsmacro{\coadvisorinfo}{institute,title,email}
    \tsmacro{\examinerinfo}{institute,title,email}
  \end{codesyntax}
  Some extra commands to set the advisor's/coadvisor's/examiner's other data. Note, though, it is assumed that these commands will be called after the respective \tsobj[code,sep=or]{\advisor,\coadvisor,\examiner} command call.
\end{codedescribe}

\tscode*[stdemo]{student:NewAdv}[5]
\tscode*[stdemo]{student:NewAdv}[6]
\tscode*[stdemo]{student:NewAdv}[7]
\tscode*[stdemo]{student:NewAdv}[8]


\begin{codedescribe}{\examinergrades}
\begin{codesyntax}
  \tsmacro{\examinergrades}[case]{gradeA,gradeB,gradeC,gradeD}
\end{codesyntax}  
Nothing much to be said, this allows to set 4 grades, per examiner. \tsobj[oarg]{case} sets how the average shall be calculated. Note that, this is supposed to be used immediately  after the respective command \tsobj{\examiner}, better said, before another \tsobj{\examiner}, or after having selected a specific reviewer with \tsobj{\studentreviewerselect} (see \ref{student:data-recovery}).
\begin{tsremark}
  The \tsobj{\starray_gset_prop:nne} is used to assure the stored grade will be a floating point, and not an expression to be evaluated later on.
\end{tsremark}
\end{codedescribe}

\tscode*[stdemo]{student:grades}[1]



\begin{codedescribe}{\studentgrade}
\begin{codesyntax}
  \tsmacro{\studentgrade}[case]{min}
\end{codesyntax}  
Similarly, this will set/calculate the student's final grade based on the individual reviewers' grades, and the flag \tsobj[key]{flag-approved} (based on \tsobj[marg]{min}).  The optional parameter \tsobj[oarg]{case} selects how the final grade will be calculated.
\begin{tsremark}
  The \tsobj{\starray_gset_prop:nne} is used to assure the stored grade will be a floating point, and not an expression to be evaluated later on.
\end{tsremark}
\begin{tsremark}
  To simplify the logic, it's assumed there are 3 reviewers (even though in some cases only two are needed). Therefore the command \tsobj{\emptytermifnone} (see \ref{student:auxcmds});
\end{tsremark}
\end{codedescribe}

\tscode*[stdemo]{student:grades}[2]


\subsubsection{Selecting Student's Data}\label{student:data-recovery}

\begin{codedescribe}{\studentselect,\studentReviewerSelect}
\begin{codesyntax}
  \tsmacro{\studentselect}{student-hash}
  \tsmacro{\studentReviewerSelect}{rev-index}
\end{codesyntax}
 \tsobj{\studentselect} allows to select a given student, given it's hash (note, the student index could also be used). Since the \tsobj{\examiner} command (see \ref{student:new}) doesn't associate a hash with each examiner, one can only select one with it's index number: 1, 2 ...
\end{codedescribe}

\tscode*[stdemo]{student:select}[1]
\tscode*[stdemo]{student:select}[2]

\begin{codedescribe}{\studentcase,\studentadvcase,\studentcoadvcase,\studentreviewersetcase}
\begin{codesyntax}
  \tsmacro{\studentCase}{if-approved,if-not}
  \tsmacro{\studentAdvCase}{if-one,if-many}
  \tsmacro{\studentCoadvCase}{if-set,if-not}
  \tsmacro{\studentReviewerSetCase}{if-set,if-not}  
\end{codesyntax}
 Those are auxiliary conditionals. \tsobj{\studentAdvCase} tests if the student has one or more than one advisors assigned. \tsobj{\studentCoadvCase} tests if there is a co-advisor. \tsobj{\studentReviewerSetCase} tests if the current reviewer (better said, student.reviewer) is set (not the default -empty- set). And, finally, \tsobj{\studentCase} verifies the state of the flag flag-approved.
\end{codedescribe}
\begin{tsremark}
  In the code below, one could have used \tsobj{\starray_get_prop:} instead. The construct is meant as an example of how to use one of the few \tsobj{\starray_parsed_} commands, which can be used in an expandable context.
\end{tsremark}

\tscode*[stdemo]{student:cases}[1]
\tscode*[stdemo]{student:cases}[2]
\tscode*[stdemo]{student:cases}[3]
\tscode*[stdemo]{student:cases}[4]


\subsubsection{Iterating over Students}

\begin{codedescribe}{\studentiterate,\studentadvisoriterate}
  \begin{codesyntax}
    \tsmacro{\studentiterate}{code}
    \tsmacro{\studentadvisoriterate}{code}
  \end{codesyntax}
  As their name implies, they are auxiliary commands to iterate over all students, \tsobj{\studentiterate}, or all advisors of the current student, \tsobj{\studentadvisoriterate}.
\end{codedescribe}
\begin{tsremark}
  To retrieve the student's/advisor's data, the end user is supposed to use \tsobj[code,sep=or]{\DataField,\DataGet} (see \ref{generic:datafield}), like \tsverb[verb]{\DataField{student}{name}} (do not use any index/hash) or \tsobj[verb]{\DataField{student.advisor}{name}}.
\end{tsremark}
\tscode*[stdemo]{student:iter}[1]
\tscode*[stdemo]{student:iter}[2]


\subsubsection{Auxiliary Commands}\label{student:auxcmds}
\begin{codedescribe}{\emptytermifnone,\emptyfields}
  \begin{codesyntax}
    \tsmacro{\emptytermifnone}[count]{struct}\tsargs[oarg]{code}
    \tsmacro{\emptyfields}{}
  \end{codesyntax}
  \tsobj{\emptyfields} creates an ``empty'' student (better said, with a hash: ``empty'') all fields remain at their default value (see \ref{student:DataModel}). \tsobj{\emptytermifnone} assures that there is(are) at least \tsobj[oarg]{count} (defaults to 1) (sub)structures \tsobj[marg]{struct}. Optionally, \tsobj[oarg]{code} will be executer after each instantiation (if needed) of a term defined by \tsobj[marg]{struct}.
\end{codedescribe}

\tscode*[stdemo]{student:emptyterm}[1]
\tscode*[stdemo]{student:emptyterm}[2]



\subsubsection{Student's Lists}
\begin{codedescribe}{\studentaddtolist,\studentlistsort}
\begin{codesyntax}
  \tsmacro{\studentaddtolist}{list}
  \tsmacro{\studentlistsort}[field]{list}
\end{codesyntax}
A \tsobj[pkg]{starray} has an implicit order: it's instantiation sequence, which is ok, but not always. To be able the access/list the terms of it, an option is to have one (or more) associated lists. Note that those commands will just create a sequence associated with \tsobj[marg]{list}

\tsobj{\studentaddtolist} will insert a student (better said, the current student's hash) to a \tsobj[marg]{list}, if the \tsobj[marg]{list} isn't already defined, a new one will be created. \tsobj{\studentlistsort} will sort the elements of \tsobj[marg]{list} based on the value of the field \tsobj[oarg]{field} (defaults to ``name'').
\end{codedescribe}
\begin{tsremark}
  Since \tsobj[marg]{list} will store student's hash, the sort has to first retrieve the associated \tsobj[pkg]{starray} term and the ``sorting field'' which can be, in fact, anything associated with the student. In the example below, only the immediate fields can be used, like name, email, worktitle, but one can easily modify the code below to retried, for instance, the advisor's name.
\end{tsremark}

\tscode*[stdemo]{student:list}[1]

\tscode*[stdemo]{student:list}[2]

\begin{codedescribe}{\listemptytermsifnone}
\begin{codesyntax}
  \tsmacro{\listemptytermsifnone}{list}
\end{codesyntax}
This will iterate over all students in \tsobj[marg]{list} assuring that each student has at leas 1 advisor and 3 examiners (reviewers). Note that, in the case of the examiners the \tsobj{\examiner} command (see \ref{student:new}) sets the ``flag-set'' associated with said examiner to true. This, however, keeps the it's default value: false.
\end{codedescribe}

\tscode*[stdemo]{student:list}[3]


\begin{codedescribe}{\studentlistiterate}
\begin{codesyntax}
  \tsmacro{\studentlistiterate}{list,code}
\end{codesyntax}
As the name implies, it will iterate over all students in \tsobj[marg]{list} executing \tsobj[marg]{code} for each of them. Note that, before starting the iteration, \tsobj{\studentlistiterate} verifies if the list is already sorted (if not, \tsobj{\studentlistsort} will be called, with it's default) and it will make sure all students have an advisor term (and examiners) by calling \tsobj{\listemptytermsifnone}.
\end{codedescribe}

\tscode*[stdemo]{student:list}[4]

\newpage
\section{Example of Use}
\subsection{Setting Things up}

\begin{codestore}[demo:datasetting]
  \NewActivity{FW I}{fw0501}{Final Work I}
  \ActivitySetCoord{Prof. Willian S.}{Final Work Coordinator}

  \NewActivity{FW II}{fw0502}{Final Work II}
  \ActivitySetCoord[FW II]{Prof. Karen S.}{Final Work Coordinator}
  
  \NewActivity{TN A}{tn0101}{Trainees}
  \ActivitySetCoord{Prof. Samantha S.}{Trainee Program Coordinator}
\end{codestore}

\tscode*[stdemo]{demo:datasetting}

\tsexec{demo:datasetting}


\subsection{Defining per Activity Check List}


\begin{codestore}[activity:checklist]
\ActivitySelect{FW I}

\checkdef{L1C1}{docs}{Documentation OK}
\checkdef{L2C1}{prop}{Proposal OK}
\checkdef{L3C1}{advisor}{Advisor assig.}

\checkdef{L1C2}{middle}{middle term}
\checkdef{L2C2}{examiners}{Examiners assig.}

\checkdef{L1C3}{final}{Final Text}
\checkdef{L2C3}{tutorok}{Tutor approval}

\checkdef{L1C4}{text}{text approved}
\checkdef{L2C4}{graded}{examiners grade}

\checkdef{L3C5}{library}{Text Catalogued}
\end{codestore}


\begin{codestore}[activity:checklist]
\ActivitySelect{FW II}

\checkdef{L1C1}{docs}{Documentation OK}
\checkdef{L2C1}{prop}{Proposal OK}
\checkdef{L3C1}{advisor}{Advisor assig.}

\checkdef{L1C2}{middle}{middle term}
\checkdef{L2C2}{examiners}{Examiners assig.}

\checkdef{L1C3}{final}{Final Text}
\checkdef{L2C3}{tutorok}{Tutor approval}

\checkdef{L1C4}{text}{text approved}
\checkdef{L2C4}{graded}{examiners grade}

\checkdef{L3C5}{library}{Text Catalogued}
\end{codestore}


\begin{codestore}[activity:checklist]
\ActivitySelect{TN A}
\checkdef{L1C1}{docs}{Documentation OK}

\checkdef{L2C1}{tutor}{tutor assigned}

\checkdef{L1C2}{middle}{middle term report}

\checkdef{L1C3}{final}{Final Report}
\checkdef{L2C3}{tutorok}{tutor approval}

\checkdef{L1C4}{text}{text approved}

\checkdef{L3C5}{library}{Report Catalogued}
\end{codestore}

\tscode*[stdemo]{activity:checklist}[1]
\tscode*[stdemo]{activity:checklist}[2]
\tscode*[stdemo]{activity:checklist}[3]
\tsexec{activity:checklist}[1]
\tsexec{activity:checklist}[2]
\tsexec{activity:checklist}[3]

\subsection{Defining per Activity Calendar}
Setting a set of events related to an activity, and then the relevant dates.


\begin{codestore}[activity:calendar]
\ActivitySelect{FW II}

%%%%%%%%
\ActivitySetNewEvent{opening}
    {First class. Activity goals.}

\ActivitySetNewEvent{proposals}
    {Deadline for proposals submission.}

\ActivitySetNewEvent{middle term}
    {Students middle term presentation and follow-up.  }

\ActivitySetNewEvent{submission}
    {Deadline for student's work submission.}

\ActivitySetNewEvent{review}
    {Work review by examiners.}

\ActivitySetNewEvent{feedback}
    {Feedback on the work done, per student (private)}

\ActivitySetNewEvent{exam}
    {Final Exam}
\end{codestore}

\begin{codestore}[activity:calendar]
\ActivitySelect{FW II}

%%%%%%%%
\ActivitySetEventDay {opening}{01/09}{1st week}
\ActivitySetEventDay {proposals}{15/09}{3rd week}
\ActivitySetEventDay {middle term}{07/10}{6th week}
\ActivitySetEventDay {submission}{21/10}{8th week}
\ActivitySetEventDay {review}{28/10-03/11}{9th week}
\ActivitySetEventDay {feedback}{06-10/11}{10th week}
\ActivitySetEventDay {exam}{15/11}{last week}
\end{codestore}


\tscode*[stdemo]{activity:calendar}[1]

Once the events are defined, the associated dates can be set, later on, at any time. There is no need, per-se, to set the dates right away.

\tscode*[stdemo]{activity:calendar}[2]
\tsexec{activity:calendar}[1]
\tsexec{activity:calendar}[2]


\subsection{Constructing an Activity Calendar}
Once all set, it is just a matter of using the \tsobj{\ActivityCalendarIterate} to go over all the events. Note that, the sequence is exactly the original one (defined by \tsobj{\ActivitySetNewEvent}).

\begin{codestore}[activity:calendar]
\ActivitySelect{FW II}
\begin{center}
  \sc Calendar for \DataField{activity}{name}
\end{center}
  \begin{tabular}{lcl}
    \ActivityCalendarIterate{ \DataField{activity.calendar}{date} & \DataField{activity.calendar}{week} & \DataField{activity.calendar}{event} \\ }
  \end{tabular} 
\end{codestore}

\tsdemo*[stdemo]{activity:calendar}[3]

\subsection{Students}

\begin{codestore}[demo:student.data]
  \student[James S.]{Smith}{James}{ID001}{smith.james@uni.gov}
  \studentremark{2nd time}
  \worktitle{Some Useful System}

  \advisor{T.}{Jonathan}
  \advisorinfo{University of Z}{Prof.}{jon.t@uni.gov}

  \examiner{T.}{William}
  \examinergrades{10}{9}{8}{7}
  \examinerinfo{University of Z}{Prof.}{william.t@uni.gov}

  \examiner{T.}{Jame}
  \examinerinfo{University of Z}{Prof.}{jame@uni.gov}
  \examinergrades{10}{9}{8}{7} 

  \examiner{T.}{Thomaz}
  \examinerinfo{University of Z}{Prof.}{thomaz.t@uni.gov}
  \examinergrades{10}{9}{8}{7}
  
  \ActivitySelect{FW I}
  \checklist{docs,prop,advisor,middle,examiners,text,graded}
  \studentaddtolist{FW-I}
  
\end{codestore}

\begin{codestore}[demo:student.data]
  \student[Sarah S.]{Barnes}{James}{ID003}{sarah.james@uni.gov}
  \worktitle{Some Useful System}

  \advisor{T.}{Jonathan}
  \advisorinfo{University of Z}{Prof.}{jon.t@uni.gov}

  \examiner{T.}{William}
  \examinergrades{10}{9}{8}{7}
  \examinerinfo{University of Z}{Prof.}{william.t@uni.gov}

  \examiner{T.}{Jame}
  \examinerinfo{University of Z}{Prof.}{jame@uni.gov}
  \examinergrades{10}{9}{8}{7} 

  \examiner{T.}{Thomaz}
  \examinerinfo{University of Z}{Prof.}{thomaz.t@uni.gov}
  \examinergrades{10}{9}{8}{7}
  
  \ActivitySelect{FW II}
  \checklist{docs,prop,advisor,middle,examiners,text,graded,library}
  \studentaddtolist{FW-II}

\end{codestore}


\begin{codestore}[demo:student.data]
  \student[Barney]{Smith}{Barney}{ID002}{loren.s@uni.gov}
  \worktitle{Some Useful System}

  \advisor{T.}{J.J.}
  \advisorinfo{University of Z}{Prof.}{jon.t@uni.gov}

  \examiner{T.}{Ceasare}
  \examinergrades{10}{9}{8}{7}
  \examinerinfo{University of Z}{Prof.}{william.t@uni.gov}

  \examiner{T.}{Marcus}
  \examinerinfo{University of Z}{Prof.}{jame@uni.gov}
  \examinergrades{10}{9}{8}{7} 

  \examiner{T.}{Brutus}
  \examinerinfo{University of Z}{Prof.}{thomaz.t@uni.gov}
  \examinergrades{10}{9}{8}{7}

  \ActivitySelect{FW II}
  \checklist{docs,prop}
  \studentaddtolist{FW-II}

  \student[Kate]{Smithson}{Kate}{ID004}{loren.s@uni.gov}
  \worktitle{Some Useful System}

  \advisor{T.}{Jonathan}
  \advisorinfo{University of Z}{Prof.}{jon.t@uni.gov}

  \advisor{T.}{William}
  \advisorinfo{University of Z}{Prof.}{jon.t@uni.gov}

  \examiner{Aurelius}{T.}
  \examinergrades{10}{9}{8}{7}
  \examinerinfo{Uni. Z}{Prof.}{aurelius@uni.gov}

  \examiner{T.}{Cicero}
  \examinerinfo{Uni. Z}{Prof.}{cicero@uni.gov}
  \examinergrades{10}{9}{8}{7} 

%  \examiner{T.}{Plutarco}
%  \examinerinfo{Uni. Z}{Prof.}{plutarco.t@uni.gov}
%  \examinergrades{10}{9}{8}{7}

  \ActivitySelect{FW II}
  \checklist{docs,prop}
  \studentaddtolist{FW-II}

\end{codestore}
Setting student's data (some others, not shown, likely defined).


\tscode*[stdemo]{demo:student.data}[1]
\tscode*[stdemo]{demo:student.data}[2]
\tsexec{demo:student.data}[1]
\tsexec{demo:student.data}[2]
\tsexec{demo:student.data}[3]


\subsection{Accessing a single student data}
Just an example of how to select/access the data of a single student, and it's corresponding check list (associated with a given activity).

\begin{codestore}[demo:student.single-use]
\ActivitySelect{FW I}
\studentselect{James S.}
Student's Name: \DataField{student}{name}

Activity: \DataField{activity}{name}

\begingroup
  \scriptsize
  \begin{tabular}{lllll}
  \StudentCheckListTable{L1,L2,L3}{C1,C2,C3,C4,C5}
  \end{tabular}
\endgroup
\end{codestore}

\tsdemo*[stdemo]{demo:student.single-use}

\subsection{Iterating over a list of students}
Given a student list, one can just iterate over it. Note that no explicit index/hash has been used. Also note that, since the \tsobj{\studentlistiterate} executes \tsobj{\listemptytermsifnone}, there is no explicit  need to test if the student has 3 examiners.

\begin{codestore}[demo:student.list]
\studentlistsort[last]{FW-II} % sorting the students by their last name.
\studentlistiterate{FW-II}{
    \studentgrade[A]{6} %using the A (formula) and setting the minimum at 6.
    \par
    Student: \DataField{student}{name}\par
    \studentAdvCase
      { %more than one
        Advisors:
        \studentadvisoriterate
          {
            \DataField{student.advisor}{name}, ~
          }
      }
      { %just one
        Advisor: \DataField{student.advisor}{name}
      }
    \par
    
    \begin{tabular}{@{\hspace{10mm}}lll}
    \studentReviewerSelect{1} 
    1st examiner: \DataField{student.reviewer}{name} & grade: \DataField{student.reviewer}{grade} \\
    \studentReviewerSelect{2} 
    2nd examiner: \DataField{student.reviewer}{name} & grade: \DataField{student.reviewer}{grade} \\
    \studentReviewerSelect{3} 
    3rd examiner: \DataField{student.reviewer}{name} & grade: \DataField{student.reviewer}{grade} \\
    Average: \DataField{student}{grade} - \studentCase{Approved}{Failed}
    \end{tabular}

    \begingroup
      \scriptsize
      \begin{tabular}{lllll}
      \StudentCheckListTable{L1,L2,L3}{C1,C2,C3,C4,C5}
      \end{tabular}
    \endgroup
    \\[5mm]
  }
\end{codestore}

\tsdemo*[stdemo]{demo:student.list}


\end{document} 