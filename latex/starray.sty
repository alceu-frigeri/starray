\RequirePackage{ expl3}
\ProvidesExplPackage
    {starray}
    {2023/03/01}
    {0.0.1}
    {A Chemical Database}

%%%%
%%%%garbage/tests
%%%%
%%%%


%\seq_new:N \l_path_seq
%\seq_new:N \l_pathb_seq
%\tl_new:N \l_tl
%\tl_new:N \l_b_tl





%%%%
%%%% end of :: garbage/tests
%%%%
%%%%





%%%%%%%%%%%%%%%%%%%
%%%%
%%%%  New package
%%%%
%%%%%%%%%%%%%%%%%%%

%
% \l__starray_cnt integer, array counter/size
% \l__starray_iter integer, array iterator (current set)
%
%
%
%

\cs_generate_variant:Nn \prop_item:Nn { ce }
\cs_generate_variant:Nn \tl_put_right:Nn {Ne}
\cs_generate_variant:Nn \tl_set:Nn {Ne}
\cs_generate_variant:Nn \seq_put_right:Nn {ce}

\cs_generate_variant:Nn \int_to_Alph:n {e}

\cs_generate_variant:Nn \prop_put:Nnn {cee}

\prg_new_conditional:Npnn \starray_if_free:n #1 {p, T, F, TF}
  {
    \prop_if_exist:cTF {#1}
      { \prg_return_false: }
      { \prg_return_true: }
  }



\prg_new_conditional:Npnn \starray_if_valid:n #1 {p, T, F, TF}
  {
    \prop_if_exist:cTF {#1}
      {
        \bool_if:cTF { \prop_item:cn {#1} {is_starray} }
          { \prg_return_true: }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }

\prg_generate_conditional_variant:Nnn \starray_if_valid:n {e} {p, T, F, TF}


\prg_new_conditional:Npnn \starray_if_locked:n #1 {p, T, F, TF}
  {
    \prop_if_exist:cTF {#1}
      {
        \bool_if:cTF { \prop_item:cn {#1} {is_locked} }
          { \prg_return_true: }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }



\cs_new:Npn \__starray_base_new:n #1
  {
    \starray_if_free:nTF {#1 _base_prop}
    {
      \prop_new:c { #1 _base_prop }

      \prop_set_from_keyval:cn
        { #1 _base_prop }
        {
          self_prefix = #1 ,
          def         = #1 _def_prop ,
          is_starray  = #1 _base_is_starray_bool ,
          cnt         = #1 _cnt_int ,
          iter        = #1 _iter_int ,
          seq         = #1 _seq ,
          full_hash   = #1 _hash_prop ,
          idx_hash    = #1 _idx_hash_prop ,

        }

      \bool_new:c
        { \prop_item:cn {#1 _base_prop} {is_starray} }
      \bool_set_true:c
        { \prop_item:cn {#1 _base_prop} {is_starray} }

      \int_new:c
        { \prop_item:cn {#1 _base_prop} {cnt} }
      \int_zero:c
        { \prop_item:cn {#1 _base_prop} {cnt} }

      \int_new:c
        { \prop_item:cn {#1 _base_prop} {iter} }
      \int_zero:c
        { \prop_item:cn {#1 _base_prop} {iter} }

      \seq_new:c
        { \prop_item:cn {#1 _base_prop} {seq} }

      \prop_new:c
        { \prop_item:cn {#1 _base_prop} {full_hash} }

      \prop_new:c
        { \prop_item:cn {#1 _base_prop} {idx_hash} }
    }
    { err:#1 _base ~~ already ~~ defined! }
  }

\cs_generate_variant:Nn \__starray_base_new:n { e }

\cs_new:Npn \__starray_sub_base_new:nn #1#2
{ \__starray_base_new:e {#1.#2} }


%\cs_new:Npn \__starray_new_def:n #1
%{
%    \prop_new:c {#1}
%    \prop_put:cnn {#1}
%}

\cs_new:Npn \__starray_new:n #1
  {
    \starray_if_free:nTF {#1 _prop}
      {
        \prop_new:c
          { #1 _prop }

        \prop_set_from_keyval:cn
          { #1 _prop }
          {
            def        = #1 _def_prop ,
            is_starray = #1 _is_starray_bool ,
            is_locked  = #1 _is_locked_bool
          }

        \prop_new:c
          { \prop_item:cn {#1 _prop} {def} }

        \prop_set_from_keyval:cn
          { #1 _def_prop }
          {
            ..st_seq    = #1 _def_st_seq       ,   %%sequence of sub-starrays
            ..keys_seq    = #1 _def_keys_seq       %%sequence of keys
          }

        \seq_new:c
          { \prop_item:cn { #1 _def_prop } { ..keys_seq } }

        \seq_new:c
          { \prop_item:cn { #1 _def_prop } { ..st_seq } }

        \bool_new:c
          { \prop_item:cn {#1 _prop} {is_starray} }
        \bool_set_true:c
          { \prop_item:cn {#1 _prop} {is_starray} }

        \bool_new:c
          { \prop_item:cn {#1 _prop} {is_locked} }
        \bool_set_false:c
          { \prop_item:cn {#1 _prop} {is_locked} }

        \__starray_base_new:e {#1} % TODO: might be incomplete !!!
      }
      { err:#1~~ already~~ defined! }
  }

\cs_new:Npn \starray_new:n #1
  {
    \__starray_new:n { l__starray_ #1 }
  }


%%%%%%%%%%%%
%%%%
%%%% get root reference (first term) assuming called as
%%%%    <st-ref> . \q_nil \q_stop
%%%% so that even if {ref} (no dot, no idx) it will return 'the root ref'
%%%%
%%%% e.g.: \tl_set:Ne \l__tmpb_tl {\__starray_get_root:w \l__tl . \q_nil \q_stop}
%%%%
%%%%%%%%%%%%
\cs_new:Npn \__starray_get_root:w #1 . #2 \q_stop { #1 }



%adding property #2 (#3 being it's initial/default value)
%
\cs_new:Npn \__starray_add_prop:nnn #1#2#3
  {
    \starray_if_valid:nTF {#1 _prop}
      { \prop_put:cnn {#1 _def_prop} {#2} {#3} }
      { err: #1 ~ not~a~valid~~starray! }
  }




\cs_new:Npn \starray_add_prop:nnn #1#2#3
  {
    \tl_set:Ne \l__starray_tmpb_tl { \__starray_get_root:w #1 .\q_nil\q_stop }

    \starray_if_locked:nTF { l__starray_ \l__starray_tmpb_tl _prop}
      { err: ~can't  ~add ~ property ~<#2>~ to ~ <#1> }
      { \__starray_add_prop:nnn {l__starray_ #1} {#2} {#3} }
  }

%adding struct array #2 to a starray
%
\cs_new:Npn \__starray_add_struct:nn #1#2
  {
    \starray_if_valid:nTF {#1 _prop}
      {
        \prop_put:cnn
          { \prop_item:cn {#1 _prop} {def} }
          { . #2} {#1 . #2 _prop}

        \seq_put_right:cn
          { \prop_item:cn {\prop_item:cn {#1 _prop} {def}} {..st_seq} }
          {#2}

        \__starray_new:n { #1 . #2}
      }
      { err: #1 ~ not~a~valid~~starray! }
  }



\cs_new:Npn \starray_add_struct:nn #1#2
  {
    \tl_set:Ne \l__starray_tmpb_tl {\__starray_get_root:w #1 .\q_nil\q_stop}

    \starray_if_locked:nTF { l__starray_ \l__starray_tmpb_tl _prop}
      { err: ~can't  ~add ~ property ~<#2>~ to ~ <#1> }
      { \__starray_add_struct:nn {l__starray_ #1} {#2} }
  }



\cs_new:Npn \__starray_add_term:nn #1#2
  {
    \starray_if_valid:nTF {#1 _base_prop}
      {
  %        \bool_set_true:c {
  %            \prop_item:cn {#1 _prop} {is_locked}
  %        }

        \int_incr:c
          {  \prop_item:cn {#1 _base_prop} {cnt} }

        \int_set_eq:cc
          { \prop_item:cn {#1 _base_prop} {iter} }
          { \prop_item:cn {#1 _base_prop} {cnt} }

        \seq_put_right:ce
          { \prop_item:cn {#1 _base_prop} {seq} }
          { #1 _ \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } } _prop }

        \prop_put:cee
          { \prop_item:cn {#1 _base_prop} {full_hash} }
          { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } }
          { #1 _ \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } } _prop }

        \prop_put:cee
          { \prop_item:cn {#1 _base_prop} {idx_hash} }
          { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } }
          { \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } }  }

        \prop_new:c
          { #1 _ \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } } _prop }


%<<#1==#2>>
%\prop_show:c
%{ #1 _ \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } } _prop }
%
%\prop_show:c  { \prop_item:cn {#2 _base_prop} {def} }

        \prop_set_eq:cc
          { #1 _ \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } } _prop }
          { \prop_item:cn {#2 _prop} {def} }


%\prop_show:c
%{ #1 _ \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } } _prop }
%
%\prop_show:c  { \prop_item:cn {#2 _base_prop} {def} }


      % TODO: map over 'all sub-starrays parts of #2_def_prop (those starting with a dot, ..st_seq)
        \seq_map_tokens:cn
          { \prop_item:cn { \prop_item:cn {#2 _prop} {def}} {..st_seq}  }
          { \__starray_sub_base_new:nn
              { #1 _ \int_to_Alph:e { \int_use:c { \prop_item:cn {#1 _base_prop} {cnt} } } }
          }
      }
      { err:#1~~ not~ a~ valid~ starray! }
  }



\cs_new:Npn \starray_add_term:n #1
  {
    \tl_set:Ne \l__starray_tmpb_tl { \__starray_get_root:w #1 .\q_nil\q_stop }

    \starray_if_valid:nTF {l__starray_ \l__starray_tmpb_tl _prop}
      {
        \bool_set_true:c
          { \prop_item:cn {l__starray_ \l__starray_tmpb_tl _prop} {is_locked} }

        \__starray_parser:nnTF {\c_true_bool}{#1}
          {
            \__starray_add_term:nn
              {l__starray \l__starray_parsed_ref_tl }
              {l__starray \l__starray_parsed_def_ref_tl }
          }
          {false ~it~ was}
      }
      {
       invalid~root
      }
  }


%%%%%%%%%%%%%%
%%%%%%%%%%%%%%
%%%%
%%%% starray ref/address parser using quarks
%%%% could be done with seq_split and regex but
%%%% would have been even more cumbersome (and non-expandable)
%%%%
%%%% <starray_ref> := <array_ref> [ . <starray_ref> ]
%%%% <array_ref>   := <array_name> [ <term_ref> ]
%%%% <term_ref>    := \[ <number/hash> \]
%%%%
%%%%%%%%%%%%%%
%%%%%%%%%%%%%%

\tl_new:N \l__starray_parsed_term_tl
\tl_new:N \l__starray_parsed_idx_tl

\bool_new:N \__starray_parser_no_idx_ending_bool

\bool_new:N \__starray_parser_no_idx_bool % TODO: to be used (adding prop/struct)
%\bool_new:N \l__starray_parser_OK_bool

\tl_new:N \l__starray_parsed_ref_tl
\tl_new:N \l__starray_parsed_def_ref_tl
\tl_new:N \l__starray_parser_aux_tl %% when constructing parser ref, 1st underscore _ then dot .


%\tl_new:N \l__starray_tmpa_tl
\tl_new:N \l__starray_tmpb_tl
\bool_new:N \l__starray_parser_OK_bool


\prg_new_conditional:Npnn \__starray_term_parse_end:w  #1 ] #2 \q_stop { TF}
  {
    \quark_if_nil:nTF {#2}
      { \prg_return_false: } %% syntax ERR
      {
        \tl_set:Nn \l__starray_parsed_idx_tl {#1}
        \prg_return_true:
      }
  }


\prg_new_conditional:Npnn \__starray_term_parse_aux:w  #1 [ \q_nil \q_stop { TF}
  {
    \__starray_term_parse_end:wTF  #1 ] \q_nil\q_stop
      {\prg_return_true:}
      {\prg_return_false:}
  }


\prg_new_conditional:Npnn \__starray_term_parse_begin:w #1 [ #2 \q_stop { TF}
  {
    \tl_set:Nn \l__starray_parsed_term_tl {#1}

    \quark_if_nil:nTF {#2}
      {               % no 'term' ref, just array_name (current/iter term)
        \tl_clear:N \l__starray_parsed_idx_tl
        \prg_return_true:
      }
      {
        \__starray_term_parse_aux:wTF #2 \q_stop
          {\prg_return_true:}
          {\prg_return_false:}
      }
  }

%%\cs_generate_variant:Nn \prop_item:Nn { cx }



\prg_new_conditional:Npnn \__starray_if_valid_idx:nn #1#2 {p, T, F, TF}
  {
    \tl_put_right:Ne \l__starray_parsed_ref_tl
      { _
        \prop_item:ce
        {\prop_item:cn {l__starray \l__starray_parsed_ref_tl _base_prop} {idx_hash}}
        {#1}
      }
    \prop_if_exist:cTF { l__starray \l__starray_parsed_ref_tl _prop }
      {\prg_return_true:}
      {\prg_return_false:}
  }

\prg_generate_conditional_variant:Nnn \__starray_if_valid_idx:nn {ee} {p, T, F, TF}



\cs_new:Npn \__starray_ref_parse:w #1 . #2 \q_stop {
  \__starray_term_parse_begin:wTF #1 [ \q_nil \q_stop
    {                                    % syntax ok so far.
                                         % TODO: verify instance validity hash/index
                                         % vars: \l__starray_parsed_term_tl
                                         %       \l__starray_parsed_idx_tl
      \tl_put_right:Ne \l__starray_parsed_ref_tl { \l__starray_parser_aux_tl \l__starray_parsed_term_tl }
      \tl_put_right:Ne \l__starray_parsed_def_ref_tl { \l__starray_parser_aux_tl \l__starray_parsed_term_tl }
      \tl_set:Nn \l__starray_parser_aux_tl {.}

      \starray_if_valid:eTF {l__starray \l__starray_parsed_ref_tl _base_prop}
        {
          \quark_if_nil:nTF {#2}
          {       % TODO: this is the last one
            \bool_if:NTF \__starray_parser_no_idx_ending_bool
            {                                             % assuming it is to add a term...
              \tl_if_empty:NTF \l__starray_parsed_idx_tl
              { }       % done. correct
              {  <<1>>\bool_set_false:N \l__starray_parser_OK_bool } % err !
            }
            {    % TODO: assuming it is to set/get a property
              \__starray_if_valid_idx:eeTF
                {\int_use:c {\prop_item:cn {l__starray \l__starray_parsed_ref_tl _base_prop} {iter}}}
                {\l__starray_parsed_idx_tl}
                {  }      % done, finish, ok
                {<<2>>\bool_set_false:N \l__starray_parser_OK_bool}
            }
          }
          {                       % TODO: there is more to be looked at
            \__starray_if_valid_idx:eeTF
              {\int_use:c {\prop_item:cn {l__starray \l__starray_parsed_ref_tl _base_prop} {iter}}}
              {\l__starray_parsed_idx_tl}
              { \__starray_ref_parse:w #2 \q_stop }      % recurse next term
              {<<3>>\bool_set_false:N \l__starray_parser_OK_bool}
          }
        }
        { <<4:l__starray \l__starray_parsed_ref_tl _base_prop>>\bool_set_false:N \l__starray_parser_OK_bool } % invalid/ref err.
    }
    { <<5>>\bool_set_false:N \l__starray_parser_OK_bool } % syntax/ref err.
}


\prg_new_conditional:Npnn \__starray_parser:nn #1#2 {p, T, F, TF}
  {
    \bool_set_eq:NN \__starray_parser_no_idx_ending_bool #1
    \bool_set_true:N \l__starray_parser_OK_bool

    \tl_clear:N \l__starray_parsed_ref_tl
    \tl_clear:N \l__starray_parsed_def_ref_tl
    \tl_set:Nn \l__starray_parser_aux_tl {_}

    \__starray_ref_parse:w #2 .\q_nil\q_stop

  \bool_if:NTF \l__starray_parser_OK_bool
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
  }


%\tl_new:N \l__starray_tmpb_tl

