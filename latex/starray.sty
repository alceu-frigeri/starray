\RequirePackage{ expl3}
\ProvidesExplPackage
    {starray}
    {2023/03/01}
    {0.0.1}
    {A structured array/hash of properties}

%%%%%%%%%%%%%%%%%%%
%%%%
%%%%  New package
%%%%
%%%%%%%%%%%%%%%%%%%

%
% \l__starray_cnt integer, array counter/size
% \l__starray_iter integer, array iterator (current set)
%
%
%
%

% TODO: counters !!! -> \cs

\cs_generate_variant:Nn \prop_item:Nn { ce , Ne }
\cs_generate_variant:Nn \tl_put_right:Nn {Ne}
\cs_generate_variant:Nn \tl_set:Nn {Ne}
\cs_generate_variant:Nn \seq_put_right:Nn {ce}

\cs_generate_variant:Nn \int_to_Alph:n {e}

\cs_generate_variant:Nn \prop_put:Nnn {Nee , cee}

\cs_generate_variant:Nn \prop_get:NnN {Nnc , cnc}

\prg_new_conditional:Npnn \starray_if_free:n #1 {p, T, F, TF}
  {
    \prop_if_exist:cTF {#1}
      { \prg_return_false: }
      { \prg_return_true: }
  }



\prg_new_conditional:Npnn \starray_if_valid:n #1 {p, T, F, TF}
  {
    \prop_if_exist:cTF {#1}
      {
        \bool_if:nTF { \prop_item:cn {#1} {is_starray} }
          { \prg_return_true: }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }

\prg_generate_conditional_variant:Nnn \starray_if_valid:n {e} {p, T, F, TF}


\prg_new_conditional:Npnn \starray_if_unlocked:n #1 {p, T, F, TF}
  {
    \prop_if_exist:cTF {#1}
      {
        \bool_lazy_and:nnTF { \prop_item:cn {#1} {is_locked} } {  \prop_item:cn {#1} {is_starray} }
          { \prg_return_false: }
          { \prg_return_true: }
      }
      { \prg_return_false: }
  }



\cs_new:Npn \__starray_base_new:n #1
  {
    \starray_if_free:nTF {#1 _base_prop}
    {
      \int_new:c
        { #1 _cnt_int }
      \int_zero:c
        { #1 _cnt_int }

      \int_new:c
        { #1 _iter_int }
      \int_zero:c
        { #1 _iter_int }

      \prop_new:c { #1 _base_prop }

      \prop_set_from_keyval:cn
        { #1 _base_prop }
        {
          self_prefix = #1 ,
          is_starray  = \c_true_bool ,
          cnt         = \use:c {#1 _cnt_int} ,
          iter        = \use:c {#1 _iter_int}
        }


      \prop_put:cnV {#1 _base_prop} {idx_hash} \c_empty_prop

    }
    { err:#1 _base ~~ already ~~ defined! }
  }

\cs_generate_variant:Nn \__starray_base_new:n { e }

\cs_new:Npn \__starray_sub_base_new:nn #1#2
{ \__starray_base_new:e {#1.#2} }


%\cs_new:Npn \__starray_new_def:n #1
%{
%    \prop_new:c {#1}
%    \prop_put:cnn {#1}
%}

\cs_new:Npn \__starray_new:n #1
  {
    \starray_if_free:nTF {#1 _prop}
      {
        \prop_new:c
          { #1 _prop }

        \prop_set_from_keyval:cn
          { #1 _prop }
          {
%            def        = #1 _def_prop ,
            is_starray = \c_true_bool ,
            is_locked  = \c_false_bool
          }

        \prop_clear:N \l_tmpa_prop

        \prop_put:NnV \l_tmpa_prop {@st_seq} \c_empty_seq

        \prop_put:cnV
          { #1 _prop} {def} \l_tmpa_prop

        \__starray_base_new:e {#1} % TODO: might be incomplete !!!
      }
      { err:#1~~ already~~ defined! }
  }

\cs_new:Npn \starray_new:n #1
  {
    \__starray_new:n { l__starray_ #1 }
  }


%%%%%%%%%%%%
%%%%
%%%% get root reference (first term) assuming called as
%%%%    <st-ref> . \q_nil \q_stop
%%%% so that even if {ref} (no dot, no idx) it will return 'the root ref'
%%%%
%%%% e.g.: \tl_set:Ne \l__tmpb_tl {\__starray_get_root:w \l__tl . \q_nil \q_stop}
%%%%
%%%%%%%%%%%%
\cs_new:Npn \__starray_get_root:w #1 . #2 \q_stop { #1 }



%adding property #2 (#3 being it's initial/default value)
%
\cs_new:Npn \__starray_add_prop:nnn #1#2#3
  {
    \starray_if_valid:nTF {#1 _prop}
      {
%%        \prop_put:cnn {#1 _def_prop} {#2} {#3} %% old version
        \prop_get:cnN {#1 _prop} {def} \l_tmpa_prop
        \prop_put:Nnn \l_tmpa_prop {#2} {#3}
        \prop_put:cnV {#1 _prop} {def} \l_tmpa_prop
      }
      { err: #1 ~ not~a~valid~~starray! }
  }


\cs_new:Npn \starray_add_prop:nnn #1#2#3
  {
    \tl_set:Ne \l__starray_tmpb_tl { \__starray_get_root:w #1 .\q_nil\q_stop }

    \starray_if_unlocked:nTF { l__starray_ \l__starray_tmpb_tl _prop}
      {
        \__starray_add_prop:nnn {l__starray_ #1} {#2} {#3}
      }
      { err: ~can't  ~add ~ property ~<#2>~ to ~ <#1> }
  }

%adding struct array #2 to a starray
%
\cs_new:Npn \__starray_add_struct:nn #1#2
  {
    \prop_get:cnN {#1 _prop} {def} \l_tmpa_prop
    \prop_get:NnN \l_tmpa_prop {@st_seq} \l_tmpa_seq
    \seq_put_right:Nn \l_tmpa_seq {#2}
    \prop_put:NnV \l_tmpa_prop {@st_seq} \l_tmpa_seq
    \prop_put:cnV {#1 _prop} {def} \l_tmpa_prop

    \__starray_new:n { #1 . #2}
  }



\cs_new:Npn \starray_add_struct:nn #1#2
  {
    \tl_set:Ne \l__starray_tmpb_tl {\__starray_get_root:w #1 .\q_nil\q_stop}

    \starray_if_unlocked:nTF { l__starray_ \l__starray_tmpb_tl _prop}
      { \__starray_add_struct:nn {l__starray_ #1} {#2} }
      { err: ~can't  ~add ~ property ~<#2>~ to ~ <#1> }
  }



\cs_new:Npn \__starray_add_term:nn #1#2
  {
    \starray_if_valid:nTF {#1 _base_prop}
      {
        \int_incr:N
            {\prop_item:cn {#1 _base_prop} {cnt} }

        \int_set_eq:NN
           {\prop_item:cn {#1 _base_prop} {iter} }
           {\prop_item:cn {#1 _base_prop} {cnt} }

        \prop_get:cnN {#1 _base_prop} {idx_hash} \l_tmpa_prop
        \prop_put:Nee \l_tmpa_prop
          { \int_use:N  \prop_item:cn {#1 _base_prop} {cnt}  }
          { \int_to_Alph:e { \prop_item:cn {#1 _base_prop} {cnt} }  }
        \prop_put:cnV  {#1 _base_prop} {idx_hash} \l_tmpa_prop

        \tl_set:Ne \l_tmpa_tl { \int_to_Alph:e {  \prop_item:cn {#1 _base_prop} {cnt} }  }

        \prop_new:c
          { #1 _ \l_tmpa_tl _prop }

         \prop_get:cnN {#2 _prop} {def} \l_tmpa_prop
         \prop_set_eq:cN { #1 _ \l_tmpa_tl _prop } \l_tmpa_prop

         \prop_get:NnN \l_tmpa_prop {@st_seq} \l_tmpa_seq

%            \prop_get:cnc {#2 _prop} {def}
%              { #1 _ \l_tmpa_tl _prop }

            \prop_get:cnN {#2 _prop} {def} \l_tmpa_prop

             \prop_get:cnN
              { #1 _ \l_tmpa_tl _prop }
              { @st_seq }
              \l_tmpa_seq

% TODO: map over 'all sub-starrays parts of #2_def_prop (those starting with a dot, @st_seq)
        \seq_map_tokens:Nn
          \l_tmpa_seq
          { \__starray_sub_base_new:nn
              { #1 _ \l_tmpa_tl }
          }


      }
      { err:#1~~ not~ a~ valid~ starray! }
  }



\cs_new:Npn \starray_add_term:n #1
  {
    \tl_set:Ne \l__starray_tmpb_tl { \__starray_get_root:w #1 .\q_nil\q_stop }

%<<>> \l__starray_tmpb_tl ~::~\l__starray_parsed_ref_tl ~::~\l__starray_parsed_def_ref_tl \par

    \starray_if_valid:nTF {l__starray_ \l__starray_tmpb_tl _prop}
      {
        \prop_put:cnn   {l__starray_ \l__starray_tmpb_tl _prop} {is_locked}{\c_true_bool}

        \__starray_parser:nnTF {\c_true_bool}{#1}
          {
            <<>>{l__starray \l__starray_parsed_ref_tl }<<{l__starray \l__starray_parsed_def_ref_tl }>>
            \__starray_add_term:nn
              {l__starray \l__starray_parsed_ref_tl }
              {l__starray \l__starray_parsed_def_ref_tl }
          }
          {false ~it~ was}
      }
      {
       invalid~root
      }
  }



\cs_new:Npn \__starray_get_prop:nn #1#2
  {
%    \tl_set:Ne \l__starray_tmpb_tl { \__starray_get_root:w #1 .\q_nil\q_stop }

%    \starray_if_valid:nTF {l__starray_ \l__starray_tmpb_tl _prop}
%    {
      \__starray_parser:nnTF {\c_false_bool}{#1}
      {
        <<>> \l__starray_parsed_ref_tl \par
        \prop_item:cn {l__starray \l__starray_parsed_ref_tl _prop}{#2}
        <<>>
%        \__starray_add_term:nn
%        {l__starray \l__starray_parsed_ref_tl }
%        {l__starray \l__starray_parsed_def_ref_tl }
      }
      {false ~it~ was}
 %   }
%    {
%      invalid~root
%    }

  }


%%%%%%%%%%%%%%
%%%%%%%%%%%%%%
%%%%
%%%% starray ref/address parser using quarks
%%%% could be done with seq_split and regex but
%%%% would have been even more cumbersome (and non-expandable)
%%%%
%%%% <starray_ref> := <array_ref> [ . <starray_ref> ]
%%%% <array_ref>   := <array_name> [ <term_ref> ]
%%%% <term_ref>    := \[ <number/hash> \]
%%%%
%%%%%%%%%%%%%%
%%%%%%%%%%%%%%

\tl_new:N \l__starray_parsed_term_tl
\tl_new:N \l__starray_parsed_idx_tl

\bool_new:N \l__starray_parser_no_idx_ending_bool

\bool_new:N \l__starray_parser_no_idx_bool % TODO: to be used (adding prop/struct)
%\bool_new:N \l__starray_parser_OK_bool

\tl_new:N \l__starray_parsed_ref_tl
\tl_new:N \l__starray_parsed_def_ref_tl
\tl_new:N \l__starray_parser_aux_tl %% when constructing parser ref, 1st underscore _ then dot .


%\tl_new:N \l__starray_tmpa_tl
\tl_new:N \l__starray_tmpb_tl
\bool_new:N \l__starray_parser_OK_bool


\prg_new_conditional:Npnn \__starray_term_parse_end:w  #1 ] #2 \q_stop { TF}
  {
    \quark_if_nil:nTF {#2}
      { \prg_return_false: } %% syntax ERR
      {
        \tl_set:Nn \l__starray_parsed_idx_tl {#1}
        \prg_return_true:
      }
  }


\prg_new_conditional:Npnn \__starray_term_parse_aux:w  #1 [ \q_nil \q_stop { TF}
  {
    \__starray_term_parse_end:wTF  #1 ] \q_nil\q_stop
      {\prg_return_true:}
      {\prg_return_false:}
  }


\prg_new_conditional:Npnn \__starray_term_parse_begin:w #1 [ #2 \q_stop { TF}
  {
    \tl_set:Nn \l__starray_parsed_term_tl {#1}

    \quark_if_nil:nTF {#2}
      {               % no 'term' ref, just array_name (current/iter term)
        \tl_clear:N \l__starray_parsed_idx_tl
        \prg_return_true:
      }
      {
        \__starray_term_parse_aux:wTF #2 \q_stop
          {\prg_return_true:}
          {\prg_return_false:}
      }
  }


% TODO: verify #2 before going for #1 . . .
% TODO: if #2 isn't empty test for it return true/false
% TODO: if #2 is empty, test if #1 is valid, return true/false
\prg_new_conditional:Npnn \__starray_if_valid_idx:nn #1#2 {p, T, F, TF}
  {
    \prop_get:cnN {l__starray \l__starray_parsed_ref_tl _base_prop} {idx_hash} \l_tmpa_prop

    \tl_put_right:Ne \l__starray_parsed_ref_tl
      {  _  \prop_item:Ne \l_tmpa_prop {#1} }
    \prop_if_exist:cTF { l__starray \l__starray_parsed_ref_tl _prop }
      {\prg_return_true:}
      {\prg_return_false:}
  }

\prg_generate_conditional_variant:Nnn \__starray_if_valid_idx:nn {ee} {p, T, F, TF}



\cs_new:Npn \__starray_ref_parse:w #1 . #2 \q_stop {
  \__starray_term_parse_begin:wTF #1 [ \q_nil \q_stop
    {                                    % syntax ok so far.
                                         % TODO: verify instance validity hash/index
                                         % vars: \l__starray_parsed_term_tl
                                         %       \l__starray_parsed_idx_tl
      \tl_put_right:Ne \l__starray_parsed_ref_tl { \l__starray_parser_aux_tl \l__starray_parsed_term_tl }
      \tl_put_right:Ne \l__starray_parsed_def_ref_tl { \l__starray_parser_aux_tl \l__starray_parsed_term_tl }
      \tl_set:Nn \l__starray_parser_aux_tl {.}

      \starray_if_valid:eTF {l__starray \l__starray_parsed_ref_tl _base_prop}
        {
          \quark_if_nil:nTF {#2}
          {       % TODO: this is the last one
            \bool_if:NTF \l__starray_parser_no_idx_ending_bool
            {                                             % assuming it is to add a term...
              \tl_if_empty:NTF \l__starray_parsed_idx_tl
              { }       % done. correct
              {  <<1>>\bool_set_false:N \l__starray_parser_OK_bool } % err !
            }
            {    % TODO: assuming it is to set/get a property
                % TODO: test the given idx (and not iter...)
              \__starray_if_valid_idx:eeTF
                {\int_use:N \prop_item:cn {l__starray \l__starray_parsed_ref_tl _base_prop} {iter}}
                {\l__starray_parsed_idx_tl}
%                {\l__starray_parsed_idx_tl}
                {  }      % done, finish, ok
                {<<2>>\bool_set_false:N \l__starray_parser_OK_bool}
            }
          }
          {                       % TODO: there is more to be looked at
            \__starray_if_valid_idx:eeTF
              {\int_use:N \prop_item:cn {l__starray \l__starray_parsed_ref_tl _base_prop} {iter}}
              {\l__starray_parsed_idx_tl}
%              {\l__starray_parsed_idx_tl}
              { \__starray_ref_parse:w #2 \q_stop }      % recurse next term
              {<<3>>\bool_set_false:N \l__starray_parser_OK_bool}
          }
        }
        { <<4:l__starray \l__starray_parsed_ref_tl _base_prop>>\bool_set_false:N \l__starray_parser_OK_bool } % invalid/ref err.
    }
    { <<5>>\bool_set_false:N \l__starray_parser_OK_bool } % syntax/ref err.
}

%%%%%%%%%%%%%%%%%
%%%%
%%%% parser 'true' returns:
%%%%                       \l__starray_parsed_ref_tl
%%%%                       \l__starray_parsed_def_ref_tl
%%%%
%%%%%%%%%%%%%%%%%

\prg_new_conditional:Npnn \__starray_parser:nn #1#2 {p, T, F, TF}
  {
    \bool_set_eq:NN \l__starray_parser_no_idx_ending_bool #1
    \bool_set_true:N \l__starray_parser_OK_bool

    \tl_clear:N \l__starray_parsed_ref_tl
    \tl_clear:N \l__starray_parsed_def_ref_tl
    \tl_set:Nn \l__starray_parser_aux_tl {_}

    \__starray_ref_parse:w #2 .\q_nil\q_stop

  \bool_if:NTF \l__starray_parser_OK_bool
    {
      \prg_return_true:
    }
    {
      \prg_return_false:
    }
  }


%\tl_new:N \l__starray_tmpb_tl

