\RequirePackage{ expl3}
\ProvidesExplPackage
    {starray}
    {2023/03/01}
    {0.0.1}
    {A structured array/hash of properties}


%%%%%%%%%%%%%%%%%%%
%%%%
%%%%  New package
%%%%
%%%%%%%%%%%%%%%%%%%

\tl_new:N \l__starray_prefix_tl
%\tl_gset:Nn \l__starray_prefix_tl {l__starray_}


\keys_define:nn { starray }
{
  prefix .tl_set:N = \l__starray_prefix_tl ,
  prefix .value_required:n = true ,
  prefix .initial:n = l__starray_ ,
  prefix .usage:n = load ,

  msg-err .choice: ,
  msg-err / none .code:n = {
        \msg_redirect_module:nnn { starray  } { warning } { none }
      },
  msg-err / default .code:n = {} ,
  msg-err / strict .code:n = {
        \msg_redirect_module:nnn { starray / strict } { warning } { error }
      },
  msg-err / syntax .code:n = {
        \msg_redirect_module:nnn { starray / strict } { warning } { error }
        \msg_redirect_module:nnn { starray / syntax } { warning } { error }
      } ,
  msg-err / reference .code:n = {
        \msg_redirect_module:nnn { starray / strict } { warning } { error }
        \msg_redirect_module:nnn { starray / syntax } { warning } { error }
        \msg_redirect_module:nnn { starray / reference } { warning } { error }
      } ,
  msg-err / all .code:n = \msg_redirect_module:nnn { starray } { warning } { error } ,
  msg-err . usage:n = load ,

  msg-supress .choice: ,
  msg-supress / none .code:n = {} ,
  msg-supress / reference .code:n = {} ,
  msg-supress / reference .code:n = {
    \msg_redirect_module:nnn { starray / reference } { warning } { none }
  },
  msg-supress / syntax .code:n = {
    \msg_redirect_module:nnn { starray / strict } { warning } { none }
    \msg_redirect_module:nnn { starray / syntax } { warning } { none }
  } ,
  msg-supress / strict .code:n = {
    \msg_redirect_module:nnn { starray / strict } { warning } { none }
    \msg_redirect_module:nnn { starray / syntax } { warning } { none }
    \msg_redirect_module:nnn { starray / reference } { warning } { none }
  } ,
  msg-supress / all .code:n = \msg_redirect_module:nnn { starray } { warning } { none } ,
  msg-supress . usage:n = load ,


}

\ProcessKeyOptions [ starray ]

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% New variants of core expl3 primitives
%%%% expansion handling
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\cs_generate_variant:Nn \prop_item:Nn { ce , Ne }
\cs_generate_variant:Nn \tl_put_right:Nn {Ne}
\cs_generate_variant:Nn \tl_gput_right:Nn {Ne}
\cs_generate_variant:Nn \tl_set:Nn {Ne , ce}
\cs_generate_variant:Nn \tl_gset:Nn {Ne , ce}

\cs_generate_variant:Nn \seq_put_right:Nn {ce}
\cs_generate_variant:Nn \seq_gput_right:Nn {ce}

\cs_generate_variant:Nn \int_to_Alph:n {e}

\cs_generate_variant:Nn \prop_put:Nnn {Nee , cee}
\cs_generate_variant:Nn \prop_gput:Nnn {Nee , cee}

\cs_generate_variant:Nn \prop_get:NnN {Nnc , cnc , Nec , cec}

\prg_generate_conditional_variant:Nnn \prop_get:NnN {Nnc , cnc , Nec , cec} {p , F , T , TF}

\prg_generate_conditional_variant:Nnn \seq_if_in:Nn {ce} {TF}
\prg_generate_conditional_variant:Nnn \prop_if_in:Nn {ce} {TF}

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% Package Variables declaration
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
% TODO variables declaration

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% Package error/warning messages
%%%% #1 'ID' (code identifier)
%%%% #2 / #3 / #4  further fields (as needed)
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\msg_new:nnnn {starray} {strict / (re)define}
  {
    (ID:#1)~'#2'~already~defined!
  }
  {
    You~tried~to~(re)define~'#2'.
    ~Error~Code~ ID:<#1>.
  }


\msg_new:nnnn {starray} {syntax / ref-syntax-err}
  {
    (ID:#1)~term~reference~'#2'~error~at~'#3'.
  }
  {
    Your~term~'#2'~contains~a~syntax~error.~It's~ok~until~'#3'.
    ~Error~ Code~ ID:<#1>.
  }

\msg_new:nnnn {starray} {syntax /  term}
  {
    (ID:#1)~'#2'~isn't~a~valid~term~ref.
  }
  {
    Invalid~term~reference:~'#2'.
    ~Error~ Code~ ID:<#1>.
  }

\msg_new:nnnn {starray} {syntax /  structure-ref}
  {
    (ID:#1)~'#3'~isn't~a~sub-structure~of~'#2'.
  }
  {
    '#2' ~doesn't~have~a~sub-structure~named:~'#3'.
    ~Error~ Code~ ID:<#1>.
  }

\msg_new:nnnn {starray} {syntax /  iter}
  {
    (ID:#1)~cannot~set~iter. ~invalid~'#2'.
  }
  {
    cannot~set~iter.~ invalid '#2'.
    ~Error~ Code~ ID:<#1>.
  }


\msg_new:nnnn {starray} {syntax /  prop}
  {
    (ID:#1)~cannot~get/set~property~from~'#2'.
  }
  {
    You~have~referenced~an~invalid~structur~'#2'.
    ~Error~ Code~ ID:<#1>.
  }


\msg_new:nnnn {starray} {reference / invalid-starray}  %%%$$
  {
    (ID:#1)~'#2'~invalid~starray.
    \tl_if_blank:nTF {#3}
      {~#3}
      {}
  }
  {
    '#2'~isn't~a~starray.
    \tl_if_blank:nTF {#3}
      {~#3}
      {}
    ~Error~ Code~ ID:<#1>.
  }

\msg_new:nnnn {starray} {reference / iter}
  {
    (ID:#1)~invalid~iter~(#3)~from~'#2'
    \str_if_empty:nTF {#4}
      {}
      {#4}
    .
  }
  {
    Invalid~iter~(#3)~from~ '#2'.~You~might~have~tried~to~use/set/reset~an~iter~of~an~ill~instantiated~structured.
    ~Error~ Code~ ID:<#1>.
  }

\msg_new:nnnn {starray} {reference / prop} %%%$$
  {
    (ID:#1)~cannot~get/set~property~'#3'~from~'#2'.
  }
  {
    '#3'~isn't~a~property~of~'#2'.
    ~Error~ Code~ ID:<#1>.
  }

\msg_new:nnnn {starray} {info / show}
  {
    \iow_newline:(ID:#1)\iow_newline:~ #2 \iow_newline:

    #3

    \iow_newline:
    definition's~end.
  }
  {
    \iow_newline:(ID:#1)\iow_newline:~ #2 \iow_newline:

    #4

    \iow_newline:
    definition's~end.
  }

\seq_new:N \l__starray_msg_seq

\cs_new:Npn \__starray_msg:nnnnn #1#2#3#4#5
  {
    \bool_set_false:N \l__starray_rtn_bool

    \seq_gput_right:Nn \l__starray_msg_seq
      {
        \msg_warning:nnnnnn
          {starray}{ #1 } { #2 }{ #3 }{ #4 }{ #5 }
      }
  }

\cs_generate_variant:Nn \__starray_msg:nnnnn { nneee }

\cs_new:Npn \__starray_msg_dispatch:
  {
    \seq_map_tokens:Nn \l__starray_msg_seq {  }
    \seq_clear:N \l__starray_msg_seq
  }


%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% Package conditionals
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\prg_new_conditional:Npnn \__starray_if_free:n #1 {p, T, F, TF}
  {
    \prop_if_exist:cTF {#1}
      { \prg_return_false: }
      { \prg_return_true: }
  }

\prg_generate_conditional_variant:Nnn \__starray_if_free:n {e} {p, T, F, TF}

\prg_new_conditional:Npnn \__starray_if_valid:n #1 {p, T, F, TF}
  {
    \bool_lazy_and:nnTF {\prop_if_exist_p:c {#1}} {\prop_item:cn {#1} {is_starray}}
      { \prg_return_true: }
      { \prg_return_false: }
  }

\prg_generate_conditional_variant:Nnn \__starray_if_valid:n {e} {p, T, F, TF}

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% starray \...._new declarations
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%


\cs_new:Npn \__starray_base_new:nn #1#2
  {
    \int_new:c
      { \l__starray_prefix_tl #2 _cnt_int }
    \int_gzero:c
      { \l__starray_prefix_tl #2 _cnt_int }

    \int_new:c
      { \l__starray_prefix_tl #2 _iter_int }
    \int_gzero:c
      { \l__starray_prefix_tl #2 _iter_int }

    \prop_new:c { \l__starray_prefix_tl #2 _base_prop }

    \prop_gset_from_keyval:cn
      { \l__starray_prefix_tl #2 _base_prop }
      {
        def_ref = #1 ,
        is_starray  = \c_true_bool ,
      }

    \prop_gput:cno
      { \l__starray_prefix_tl #2 _base_prop }
      { cnt }
      { \use:c { \l__starray_prefix_tl #2 _cnt_int } }

    \prop_gput:cno
      { \l__starray_prefix_tl #2 _base_prop }
      { iter }
      { \use:c {\l__starray_prefix_tl #2 _iter_int} }

    \prop_gput:cnV
      { \l__starray_prefix_tl #2 _base_prop }
      { idx_hash }
      \c_empty_prop
  }

\cs_generate_variant:Nn \__starray_base_new:nn { ee }


\cs_new:Npn \__starray_sub_base_new:nnn #1#2#3
  { \__starray_base_new:ee {#1.#3}{#2.#3} }


\cs_new:Npn \__starray_new:n #1
  {
    \prop_new:c
      { \l__starray_prefix_tl #1 _def_prop }

    \prop_gset_from_keyval:cn
      { \l__starray_prefix_tl #1 _def_prop }
      {
        is_starray = \c_true_bool ,
        def_ref   = #1
      }

    \prop_gclear:N \l_tmpa_prop

    \prop_gput:cnV { \l__starray_prefix_tl #1 _def_prop } {@st_seq} \c_empty_seq

    \prop_gput:cnV
      { \l__starray_prefix_tl #1 _def_prop} {def} \l_tmpa_prop

    \__starray_base_new:ee {#1}{#1} % TODO: might be incomplete !!!
  }

\cs_generate_variant:Nn \__starray_new:n { e }


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_new
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_new:n #1
  {
    \__starray_if_free:nTF {\l__starray_prefix_tl #1 _def_prop}
      {
        \__starray_new:e {#1 }
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnnn {starray} {strict / (re)define} {new:1} {#1}
      }
  }


\prg_new_conditional:Npnn \starray_new:n #1 {p, T, F, TF}
  {
    \__starray_if_free:nTF {\l__starray_prefix_tl #1 _def_prop}
      {
        \__starray_new:e {#1 }
        \prg_return_true:
      }
      { \prg_return_false: }
  }

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% starray ref parser
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% get root reference (first term) assuming called as
%%%%    <st-ref> . \q_nil \q_stop
%%%% so that even if {ref} (has no dot, no idx) it will return 'the root ref'
%%%%
%%%% e.g.: \tl_set:Ne \l__tmpb_tl {\__starray_get_root:w \l__starray_tmpa_tl . \q_nil \q_stop}
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \__starray_get_root:w #1 . #2 \q_stop { #1 }


%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% adding property #3 (#4 being it's initial/default value)
%%%%    #1 prefix
%%%%    #2 starray
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%


\cs_new:Npn \__starray_def_prop:nnn #1#2#3
  {
    \prop_get:cnN {\l__starray_prefix_tl #1 _def_prop} {def} \l_tmpa_prop
    \prop_gput:Nnn \l_tmpa_prop {#2} {#3}
    \prop_gput:cnV {\l__starray_prefix_tl #1 _def_prop} {def} \l_tmpa_prop
  }



%%%%%%%%%%%%%%%
%%%%
%%%% \starray_def_prop
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_def_prop:nnn #1#2#3
  {
    \__starray_if_valid:nTF {\l__starray_prefix_tl #1 _def_prop}
      { \__starray_def_prop:nnn  {#1} {#2} {#3} }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnxxx {starray}{reference / invalid-starray} {addprop:1} {#1} {cannot~add~property:#2}
      }
  }


\prg_new_conditional:Npnn \starray_def_prop:nnn #1#2#3 {p, T, F, TF}
  {
    \__starray_if_valid:nTF {\l__starray_prefix_tl #1 _def_prop}
      {
        \__starray_def_prop:nnn  {#1} {#2} {#3}
        \prg_return_true:
      }
      { \prg_return_false: }
  }


%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% adding struct array #2 to a starray
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \__starray_def_struct:nn #1#2
  {
    \prop_get:cnN {\l__starray_prefix_tl #1 _def_prop} {@st_seq} \l_tmpa_seq
    \seq_gput_right:Nn \l_tmpa_seq {#2}

    \prop_gput:cnV {\l__starray_prefix_tl #1 _def_prop} {@st_seq} \l_tmpa_seq

    \__starray_new:e { #1 . #2}

    %TODO: see below 'fix_terms'
  }

\cs_generate_variant:Nn \__starray_def_struct:nn {ne}


%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% fixing struct _base for already instantiated terms
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%TODO: recurse over 'terms' to fix a 'late addtion' (after being instantiated?)

\cs_new:Npn \__starray_fix_terms_seq_aux:nnnnn #1#2#3#4#5
{
  \__starray_if_valid:eTF {\l__starray_prefix_tl #3 _ #4 . #5 _base_prop}
    {
     \__starray_fix_terms:nnn {#1 A}{#2.#5}{#3_#4.#5}
    }
    {
     \__starray_base_new:ee {#2.#5}{#3_#4.#5}
    }
}

\cs_new:Npn \__starray_fix_terms_seq:nnnnn #1#2#3#4#5
{
  \prop_get:cnN
    {\l__starray_prefix_tl #3 _base_prop}
    {def_ref}
    \l_tmpa_tl
    \prop_show:c {\l__starray_prefix_tl #3 _base_prop}
  \prop_get:cec
    {\l__starray_prefix_tl \l_tmpa_tl _def_prop}
    {@st_seq}
    {l__starray_tmp #1 A_seq}
  \seq_map_tokens:cn
    {l__starray_tmp #1 A_seq}
    {\__starray_fix_terms_seq_aux:nnnnn {#1}{#2}{#3}{#5}}

}

\cs_new:Npn \__starray_fix_terms:nnn #1#2#3
{
  \prop_get:cnc
    {\l__starray_prefix_tl #3 _base_prop}
    {idx_hash}
    {l__starray_tmp #1 A_prop}
  \prop_if_empty:cF {l__starray_tmp #1 A_prop}
    {
      \prop_map_tokens:cn
        {l__starray_tmp #1 A_prop}
        {\__starray_fix_terms_seq:nnnnn {#1}{#2}{#3}}
    }
}

\cs_generate_variant:Nn \__starray_fix_terms:nnn {nee}



\cs_new:Npn \starray_fix_terms:n #1
{
  \tl_set:Ne \l_tmpb_tl {\__starray_get_root:w #1 . \q_nil \q_stop}

  \__starray_if_valid:nTF { \l__starray_prefix_tl \l_tmpb_tl _def_prop}
    {
      \__starray_fix_terms:nee {}{\l_tmpb_tl}{\l_tmpb_tl}
    }
    {
      \bool_set_false:N \l__starray_rtn_bool
      \msg_warning:nnxxx {starray}{reference / invalid-starray} {addstruct:1} {#1} {cannot~add~structure:}
    }
}



%%%%%%%%%%%%%%%
%%%%
%%%% \starray_def_struct
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_def_struct:nn #1#2
  {
    \__starray_if_valid:nTF { \l__starray_prefix_tl #1 _def_prop}
      {
        \__starray_def_struct:nn  {#1} {#2}
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnxxx {starray}{reference / invalid-starray} {addstruct:1} {#1} {cannot~add~structure:#2}
      }
  }

\prg_new_conditional:Npnn \starray_def_struct:nn #1#2 {p, T, F, TF}
  {
    \__starray_if_valid:nTF { \l__starray_prefix_tl #1 _def_prop}
      {
        \__starray_def_struct:nn  {#1} {#2}
        \prg_return_true:
      }
      { \prg_return_false: }
  }


%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% adding prop/struct from keyval
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%


\prg_new_conditional:Npnn \__starray_def_from_keyval_testdot_aux:w  #1 . \q_nil { p, TF}
  {
    \str_compare:nNnTF {#1} = {struct}
      { \prg_return_true: }
      { \prg_return_false: }
  }


\prg_new_conditional:Npnn \__starray_def_from_keyval_testdot:w  #1 . #2 \q_stop { TF}
  {
    \quark_if_nil:nTF {#2}
      {
        \prg_return_false:
      } %% syntax ERR
      {
        \__starray_def_from_keyval_testdot_aux:wTF #2
          {
            \tl_set:Ne \l__starray_tmpST_tl { #1 }
            \prg_return_true:
          }
          {
            \prg_return_false:
          }
      }
  }


\cs_new:Npn \__starray_def_from_keyval_parse:nnnn #1#2#3#4
  {
    \__starray_def_from_keyval_testdot:wTF #3 . \q_nil \q_stop
      {
        \tl_set:ce {l__starray_tmp #1 _tl} {#2.\l__starray_tmpST_tl}
        \__starray_def_struct:ne {#2} {\l__starray_tmpST_tl}
        \keyval_parse:nnn
          {\__starray_def_from_keyval_parse:nen  {#1 A}{\tl_use:c {l__starray_tmp #1 _tl}}}
          {\__starray_def_from_keyval_parse:nenn {#1 A}{\tl_use:c {l__starray_tmp #1 _tl}}}
          {#4}
      }
      {
        \__starray_def_prop:nnn {#2} {#3} {#4}
      }
  }

\cs_generate_variant:Nn \__starray_def_from_keyval_parse:nnnn {nenn}


\cs_new:Npn \__starray_def_from_keyval_parse:nnn #1#2#3
  {
    \__starray_def_prop:nnn {#2} {#3} {}
  }

\cs_generate_variant:Nn \__starray_def_from_keyval_parse:nnn {nen}



%%%%%%%%%%%%%%%
%%%%
%%%% \starray_def_from_keyval
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_def_from_keyval:nn #1#2
  {
    \__starray_if_valid:nTF { \l__starray_prefix_tl #1 _def_prop}
      {
        \keyval_parse:nnn
          {\__starray_def_from_keyval_parse:nen  {AA}{#1}}
          {\__starray_def_from_keyval_parse:nenn {AA}{#1}}
          { #2 }
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnxxx {starray}{reference / invalid-starray} {addkeyval:1} {#1} {cannot~add:#2}
      }
  }

\cs_generate_variant:Nn \starray_def_from_keyval:nn {ne , ee}


\prg_new_conditional:Npnn \starray_def_from_keyval:nn #1#2 {p, T, F, TF}
  {
    \__starray_if_valid:nTF { \l__starray_prefix_tl #1 _def_prop}
      {
        \keyval_parse:nnn
          {\__starray_def_from_keyval_parse:nen  {AA}{#1}}
          {\__starray_def_from_keyval_parse:nenn {AA}{#1}}
          { #2 }
        \prg_return_true:
      }
      { \prg_return_false: }
  }


%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% adding terms
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \__starray_new_term:nn #1#2
  {
    \int_gincr:N
        {\prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {cnt} }

    \int_gset_eq:NN
       {\prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {iter} }
       {\prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {cnt} }


    % idx_hash Update.
    \prop_get:cnN {\l__starray_prefix_tl #1 _base_prop} {idx_hash} \l_tmpa_prop

    \prop_gput:Nee \l_tmpa_prop
      { \int_use:N  \prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {cnt}  }
      { \int_to_Alph:e { \prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {cnt} }  }

    \tl_if_blank:nF {#2}
      {
        \prop_gput:Nee \l_tmpa_prop
          { #2  }
          { \int_to_Alph:e { \prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {cnt} }  }
      }

    \prop_gput:cnV  {\l__starray_prefix_tl #1 _base_prop} {idx_hash} \l_tmpa_prop

    % creating the 'new property list' (aka. term)
    \tl_set:Ne \l_tmpa_tl
      { \int_to_Alph:e {  \prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {cnt} }  }

    \prop_new:c
      { \l__starray_prefix_tl #1 _ \l_tmpa_tl _term_prop }

    \prop_get:cnN {\l__starray_prefix_tl #1 _base_prop} {def_ref} \l_tmpb_tl

    \prop_get:cnN {\l__starray_prefix_tl \l_tmpb_tl _def_prop} {def} \l_tmpa_prop

    \prop_gset_eq:cN { \l__starray_prefix_tl #1 _ \l_tmpa_tl _term_prop } \l_tmpa_prop

    \prop_get:cnN {\l__starray_prefix_tl \l_tmpb_tl _def_prop} {@st_seq} \l_tmpa_seq

% map over 'all sub-starrays parts of def_ref -> st_seq (those starting with a dot, @st_seq)
    \seq_map_tokens:Nn
      \l_tmpa_seq
      {
        \__starray_sub_base_new:nnn
          { \l_tmpb_tl }{ #1 _ \l_tmpa_tl }
      }
  }


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_new_term
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_new_term:nn #1#2
  {
    \__starray_parser:nnTF {\c_true_bool}{#1}
      {
        \__starray_new_term:nn
          {\l__starray_parsed_ref_tl }
          {#2}
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnnn {starray}{syntax /  term}{addterm:2}{#1}
      }
  }

\prg_new_conditional:Npnn \starray_new_term:nn #1#2 {p, T, F, TF}
  {
    \__starray_parser:nnTF {\c_true_bool}{#1}
      {
        \__starray_new_term:nn
          {\l__starray_parsed_ref_tl }
          {#2}
        \prg_return_true:
      }
      { \prg_return_false: }
  }


%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% changing iterator value (recursing sub-structures)
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\bool_new:N \l__starray_rtn_bool


\cs_new:Npn \__starray_incr_iter:n #1
  {
    \int_compare:nNnTF
        {\prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {iter}} <
        {\prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {cnt}}
      {
        \int_gincr:N { \prop_item:cn {\l__starray_prefix_tl #1 _base_prop} {iter} }
      }
      {
        % TODO: should it be a potential 'warning' ???
        \bool_set_false:N \l__starray_rtn_bool
      }
  }

\cs_new:Npn \__starray_set_iter:nn #1#2
  {
    \int_compare:nNnTF {#1} > {\prop_item:cn {\l__starray_prefix_tl #2 _base_prop} {cnt}}
      {
        \bool_set_false:N \l__starray_rtn_bool

        \int_gset_eq:NN
        { \prop_item:cn {\l__starray_prefix_tl #2 _base_prop} {iter} }
        { \prop_item:cn {\l__starray_prefix_tl #2 _base_prop} {cnt} }
      }
      {
        \int_compare:nNnTF {#1} < {1}
          {
            \bool_set_false:N \l__starray_rtn_bool

            \int_gset:Nn
              { \prop_item:cn {\l__starray_prefix_tl #2 _base_prop} {iter} }
              { 1 }
          }
          {
            {
              \int_gset:Nn
                { \prop_item:cn {\l__starray_prefix_tl #2 _base_prop} {iter} }
                { #1 }
            }
          }
      }
  }

%\cs_new:Npn \__starray_set_sub_iter_aux:nnn #1#2#3
%{
%  \int_gset:Nn
%    { \prop_item:cn {\l__starray_prefix_tl #2#3 _base_prop} {iter} }
%    { 1 }
%  \__starray_set_sub_iter:nnn {#1}{#2}{#3}
%}

\cs_new:Npn \__starray_set_sub_iter:nnn #1#2#3
{
  \prop_get:cnN {\l__starray_prefix_tl #2#3 _base_prop} {idx_hash} \l_tmpa_prop

  \prop_get:NecT \l_tmpa_prop
    { \int_use:N \prop_item:cn {\l__starray_prefix_tl #2#3 _base_prop} {iter} }
    { l__starray_tmp #1 A_tl }
    {
      \prop_get:cnN {\l__starray_prefix_tl #2#3 _base_prop} {def_ref} \l_tmpa_tl

      \prop_get:cnc { \l__starray_prefix_tl \l_tmpa_tl _def_prop } { @st_seq } {l__starray_tmp #1 A_seq }

      \seq_if_empty:cF {l__starray_tmp #1 A_seq }
        {
%          \prop_show:c {\l__starray_prefix_tl #2#3 _base_prop}
%          \prop_show:c { \l__starray_prefix_tl \l_tmpa_tl _def_prop }
%          \seq_show:c {l__starray_tmp #1 A_seq}

%          \seq_map_tokens:cn
%            { l__starray_tmp #1 A_seq }
%            { \__starray_set_sub_iter_aux:nnn { #1 A } {#2#3 _ \tl_use:c {l__starray_tmp #1 A_tl} . } }
          \seq_map_variable:cNn
            { l__starray_tmp #1 A_seq }
            \l_tmpb_tl
            {
              \int_gset:Nn
                {
                  \prop_item:cn
                    { \l__starray_prefix_tl #2#3 _ \tl_use:c {l__starray_tmp #1 A_tl} .
                      \l_tmpb_tl _base_prop  }
                    {iter}
                }
                { 1 }

              \__starray_set_sub_iter:nne
                { #1 A }
                { #2#3 _ \tl_use:c {l__starray_tmp #1 A_tl} . }
                { \l_tmpb_tl }
            }
        }
    }
}

%\cs_generate_variant:Nn \__starray_set_sub_iter_aux:nnn {nne}
\cs_generate_variant:Nn \__starray_set_sub_iter:nnn {nne}


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_set_iter
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_set_iter:nn #1#2
  {
    \bool_set_true:N \l__starray_rtn_bool
    \seq_clear:N \l__starray_msg_seq

    \__starray_parser:nnTF {\c_true_bool}{#1}
      {
        \__starray_set_iter:nn {#2}{\l__starray_parsed_ref_tl}
        \__starray_set_sub_iter:nnn {}{\l__starray_parsed_ref_tl}{}
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnnn {starray} {syntax /  iter} {iter:1} {#1}
      } % returns nothing by default
  }



\prg_new_conditional:Npnn \starray_set_iter:nn #1#2 {p, T, F, TF}
  {
    \bool_set_true:N \l__starray_rtn_bool
    \seq_clear:N \l__starray_msg_seq

    \__starray_parser:nnTF {\c_true_bool}{#1}
      {
        \__starray_set_iter:nn {#2}{\l__starray_parsed_ref_tl}
        \__starray_set_sub_iter:nnn {}{\l__starray_parsed_ref_tl}{}
        \bool_if:NTF \l__starray_rtn_bool
          {\prg_return_true:}
          {\prg_return_false:}
      }
      { \prg_return_false: }
  }


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_reset_iter
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_reset_iter:n #1
  {
    \bool_set_true:N \l__starray_rtn_bool
    \seq_clear:N \l__starray_msg_seq

    \__starray_parser:nnTF {\c_true_bool}{#1}
    {
      \__starray_set_iter:nn {1}{\l__starray_parsed_ref_tl}
      \__starray_set_sub_iter:nnn {}{\l__starray_parsed_ref_tl}{}
    }
    {
      \bool_set_false:N \l__starray_rtn_bool
      \msg_warning:nnnn {starray} {syntax /  iter} {iter:4} {#1}
    } % returns nothing by default
  }


\prg_new_conditional:Npnn \starray_reset_iter:n #1 {p, T, F, TF}
{
  \bool_set_true:N \l__starray_rtn_bool
  \seq_clear:N \l__starray_msg_seq

  \__starray_parser:nnTF {\c_true_bool}{#1}
    {
      \__starray_set_iter:nn {1}{\l__starray_parsed_ref_tl}
      \__starray_set_sub_iter:nnn {}{\l__starray_parsed_ref_tl}{}
      \bool_if:NTF \l__starray_rtn_bool
        {\prg_return_true:}
        {\prg_return_false:}
    }
    { \prg_return_false: }
}


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_next_iter
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_next_iter:n #1
  {
    \bool_set_true:N \l__starray_rtn_bool
    \seq_clear:N \l__starray_msg_seq

    \__starray_parser:nnTF {\c_true_bool}{#1}
    {
      \__starray_incr_iter:n {\l__starray_parsed_ref_tl}
      \__starray_set_sub_iter:nnn {}{\l__starray_parsed_ref_tl}{}
    }
    {
      \bool_set_false:N \l__starray_rtn_bool
      \msg_warning:nnnn {starray} {syntax /  iter} {iter:5} {#1}
    } % returns nothing by default
  }



\prg_new_conditional:Npnn \starray_next_iter:n #1 {p, T, F, TF}
{
  \bool_set_true:N \l__starray_rtn_bool
  \seq_clear:N \l__starray_msg_seq

  \__starray_parser:nnTF {\c_true_bool}{#1}
    {
      \__starray_incr_iter:n {\l__starray_parsed_ref_tl}
      \__starray_set_sub_iter:nnn {}{\l__starray_parsed_ref_tl}{}
      \bool_if:NTF \l__starray_rtn_bool
        {\prg_return_true:}
        {\prg_return_false:}
    }
    { \prg_return_false: }
}

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% set/get properties
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%


\cs_new:Npn \__starray_get_prop:nn #1#2
  {
    \prop_item:cn {\l__starray_prefix_tl #1 _term_prop}{#2}
  }

\cs_generate_variant:Nn \__starray_get_prop:nn {ee}


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_get_prop
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_get_prop:nn #1#2
  {
    \__starray_parser:nnTF {\c_false_bool}{#1}
    {
      \__starray_get_prop:ee {\l__starray_parsed_ref_tl}{#2}
    }
    {
      \bool_set_false:N \l__starray_rtn_bool
      \msg_warning:nnnn {starray} {syntax /  prop} {get:1} {#1}
    } % returns nothing by default
  }

\cs_new:Npn \starray_get_prop:nnN #1#2#3
  {
    % TODO: to 'normalize it' (like get_prop:nn)
    \bool_set_true:N \l__starray_rtn_bool
    \__starray_parser:nnTF {\c_false_bool}{#1}
      {
        \prop_get:cnNF {\l__starray_prefix_tl \l__starray_parsed_ref_tl _term_prop} {#2} #3
          { \tl_set:Nn #3 {} }
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \tl_set:Nn #3 {}
        \msg_warning:nnnn {starray} {syntax /  prop} {get:1} {#1}
      } % returns nothing by default
  }


\prg_new_conditional:Npnn \starray_get_prop:nnN #1#2#3 {p, T, F, TF}
  {
    \__starray_parser:nnTF {\c_false_bool}{#1}
      {
        \prop_get:cnNTF {\l__starray_prefix_tl \l__starray_parsed_ref_tl _term_prop} {#2} #3
          {
            \prg_return_true:
          }
          {
            \tl_set:Nn #3 {}
            \prg_return_false:
          }
      }
      {
        \tl_set:Nn #3 {}
        \prg_return_false:
      } % returns nothing by default
  }


\prg_new_conditional:Npnn \starray_if_in:nn #1#2 {p, T, F, TF}
  {
    \__starray_parser:nnTF {\c_false_bool}{#1}
      {
        \prop_if_in:cnTF {\l__starray_prefix_tl \l__starray_parsed_ref_tl _term_prop} {#2}
          {
            \prg_return_true:
          }
          {
            \prg_return_false:
          }
      }
      {
        \prg_return_false:
      } % returns nothing by default
  }




\cs_new:Npn \__starray_set_prop:nnn #1#2#3
  {
    \prop_put:cnn {\l__starray_prefix_tl #1 _term_prop}{#2}{#3}
  }


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_set_prop
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_set_prop:nnn #1#2#3
  {
    \__starray_parser:nnTF {\c_false_bool}{#1}
      {
        \__starray_set_prop:nnn {\l__starray_parsed_ref_tl}{#2}{#3}
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnnn {starray} {syntax /  prop} {set:1} {#1}
      } % returns nothing by default
  }

\cs_generate_variant:Nn \starray_set_prop:nnn {nnV}



\prg_new_conditional:Npnn \starray_set_prop:nnn #1#2#3 {p, T, F, TF}
  {
    \__starray_parser:nnTF {\c_true_bool}{#1}
      {
        \__starray_set_prop:nnn {\l__starray_parsed_ref_tl}{#2}{#3}
        \prg_return_true:
      }
      { \prg_return_false: }
  }



%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% set/get properties (keyval)
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%


\prg_new_conditional:Npnn \__starray_set_parse_end:w  #1#2 ] #3 \q_stop { TF}
  {
    \quark_if_nil:nTF {#3}
      { \prg_return_false: } %% syntax ERR
      {
        \tl_set:cn {l__starray_tmp #1 :A_tl} {#2}
        \prg_return_true:
      }
  }


\prg_new_conditional:Npnn \__starray_set_parse_aux:w  #1#2 [ \q_nil \q_stop { TF}
  {
    \__starray_set_parse_end:wTF  {#1}#2 ] \q_nil\q_stop
      {\prg_return_true:}
      {\prg_return_false:}
  }


\prg_new_conditional:Npnn \__starray_set_parse_begin:w #1#2 [ #3 \q_stop { TF}
  {
    \quark_if_nil:nTF {#3}
      {               % no 'term' ref, just array_name (current/iter term)
        \tl_clear:c {l__starray_tmp #1 :A_tl}
        \prg_return_true:
      }
      {
        \tl_set:cn {l__starray_tmp #1 :B_tl}{#2}
        \__starray_set_parse_aux:wTF {#1}#3 \q_stop
        {\prg_return_true:}
        {\prg_return_false:}
      }
  }



\cs_new:Npn \__starray_set_from_keyval_parse:nnnn #1#2#3#4
  {
    \__starray_set_prop:nnn {#3}{#4}{}
  }

\cs_generate_variant:Nn \__starray_set_from_keyval_parse:nnnn {nnen}



\cs_new:Npn \__starray_set_from_keyval_parse:nnnnn #1#2#3#4#5
  {
    \tl_clear:c {l__starray_tmp #1 _tl}
    \__starray_set_parse_begin:wTF {#1}#4 [ \q_nil \q_stop
      {
        \tl_if_blank:eTF {\tl_use:c{l__starray_tmp #1 :A_tl}}
          {
            \prop_get:cnc {\l__starray_prefix_tl #2 _def_prop}{@st_seq}{l__starray_tmp #1 _seq}

            \seq_if_in:cnTF {l__starray_tmp #1 _seq}{#4}
              {
                \prop_get:cnc
                  { \l__starray_prefix_tl #3 .#4 _base_prop }
                  { idx_hash }
                  { l__starray_tmp #1 _hash_prop }
                \prop_get:cnc
                  { \l__starray_prefix_tl #3 .#4 _base_prop }
                  { iter }
                  { l__starray_tmp #1 _int }
                \int_compare:nNnTF {\int_use:c {l__starray_tmp #1 _int}} < {1}
                  {
                    \bool_set_false:N \l__starray_rtn_bool
                    \msg_warning:nnnnnn {starray} {reference / iter}
                      {setkeyval:2}{#2.#4}{-0-}{~(not~instantiated)}
                    % invalid iter / not instantiated
                  }
                  {
                    \tl_set:ce
                      { l__starray_tmp #1 _tl }
                      { #3.#4 _ \int_to_Alph:e {\int_use:c {l__starray_tmp #1 _int}} }
                    \keyval_parse:nnn
                      {
                        \__starray_set_from_keyval_parse:nnen
                          { #1 A }
                          { #2.#4 }
                          { \tl_use:c { l__starray_tmp #1 _tl } }
                      }
                      {
                        \__starray_set_from_keyval_parse:nnenn
                          { #1 A }
                          { #2.#4 }
                          { \tl_use:c { l__starray_tmp #1 _tl } }
                      }
                      { #5 }

                  }
              }
              {
                \__starray_set_prop:nnn {#3}{#4}{#5}
              }
          }
          {
            \prop_get:cnc {\l__starray_prefix_tl #2 _def_prop}{@st_seq}{l__starray_tmp #1 _seq}

            \seq_if_in:ceTF {l__starray_tmp #1 _seq}{\tl_use:c{l__starray_tmp #1 :B_tl}}
              {
                \prop_get:cnc
                  { \l__starray_prefix_tl #3. \tl_use:c{l__starray_tmp #1 :B_tl} _base_prop }
                  { idx_hash }
                  { l__starray_tmp #1 _hash_prop }
                \tl_set:ce
                  { l__starray_tmp #1 _idx_tl }
                  {
                    #3 . \tl_use:c{l__starray_tmp #1 :B_tl} _
                    \prop_item:ce
                      { l__starray_tmp #1 _hash_prop }
                      { \tl_use:c{ l__starray_tmp #1 :A_tl } }
                  }
                \tl_put_left:cn { l__starray_tmp #1 :B_tl } { #2 . }
                \prop_if_in:ceTF { l__starray_tmp #1 _hash_prop }{ \tl_use:c{l__starray_tmp #1 :A_tl}}
                  {
                    \keyval_parse:nnn
                      {
                        \__starray_set_from_keyval_parse:nnen
                        { #1 A }
                        { \tl_use:c{l__starray_tmp #1 :B_tl} }
                        { \tl_use:c { l__starray_tmp #1 _idx_tl } }
                      }
                      {
                        \__starray_set_from_keyval_parse:nnenn
                        { #1 A }
                        { \tl_use:c{l__starray_tmp #1 :B_tl} }
                        { \tl_use:c { l__starray_tmp #1 _idx_tl } }
                      }
                      { #5 }

                  }
                  {
                    \bool_set_false:N \l__starray_rtn_bool
                    \msg_warning:nnxxx {starray} {reference / iter}
                      {setkeyval:3}{#2.#4}{\tl_use:c{l__starray_tmp #1 :A_tl}}
                    % TODO: err msg
                    % invalid hash
                  }
              }
              {
                \bool_set_false:N \l__starray_rtn_bool
                \msg_warning:nnxxx {starray} {syntax / structure-ref}
                  {setkeyval:4}{#2.#4}{\tl_use:c{l__starray_tmp #1 :B_tl}}
                % TODO: err msg
                % invalid ref / not a substructure
              }
          }
      }
      {
        \bool_set_false:N \l__starray_rtn_bool
        \msg_warning:nnnn {starray} {syntax / term}
          {setkeyval:5}{#4}
        % TODO: err msg
        % invalid ref/syntax
      }
  }

\cs_generate_variant:Nn \__starray_set_from_keyval_parse:nnnnn {nnenn}


%%%%%%%%%%%%%%%
%%%%
%%%% \starray_set_from_keyval
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_set_from_keyval:nn #1#2
  {
    \bool_set_true:N \l__starray_rtn_bool
    \__starray_parser:nnTF {\c_false_bool}{#1}
    {
      \keyval_parse:nnn
        {\__starray_set_from_keyval_parse:nnen  {A}{#1}{\l__starray_parsed_ref_tl}}
        {\__starray_set_from_keyval_parse:nnenn {A}{#1}{\l__starray_parsed_ref_tl}}
        { #2 }
    }
    {
      \bool_set_false:N \l__starray_rtn_bool
      \msg_warning:nnnn {starray} {syntax /  prop} {setkeyval:1} {#1}
    } % returns nothing by default
  }



\prg_new_conditional:Npnn \starray_set_from_keyval:nn #1#2 {p, T, F, TF}
  {
    \bool_set_true:N \l__starray_rtn_bool
    \__starray_parser:nnTF {\c_false_bool}{#1}
      {
        \keyval_parse:nnn
          {\__starray_set_from_keyval_parse:nnen  {A}{#1}{\l__starray_parsed_ref_tl}}
          {\__starray_set_from_keyval_parse:nnenn {A}{#1}{\l__starray_parsed_ref_tl}}
          { #2 }
        \bool_if:NTF \l__starray_rtn_bool
          {\prg_return_true:}
          {\prg_return_false:}
      }
      { \prg_return_false: }
  }




%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% starray ref/address parser using quarks
%%%% could be done with seq_split and regex but
%%%% would have been even more cumbersome
%%%%
%%%% <starray_ref> := <array_ref> [ . <starray_ref> ]
%%%% <array_ref>   := <array_name> [ <term_ref> ]
%%%% <term_ref>    := \[ <number/hash> \]
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\tl_new:N \l__starray_parsed_term_tl
\tl_new:N \l__starray_parsed_idx_tl

\bool_new:N \l__starray_parser_no_idx_ending_bool

\bool_new:N \l__starray_parser_no_idx_bool % TODO: to be used (adding prop/struct)

\tl_new:N \l__starray_parsed_ref_tl
\tl_new:N \l__starray_parsed_base_ref_tl
\tl_new:N \l__starray_parser_aux_tl %% when constructing parser ref, 1st <nothing> then dot .

\tl_new:N \l__starray_parser_errcode_tl
\tl_new:N \l__starray_parsed_tl


%\tl_new:N \l__starray_tmpa_tl
\tl_new:N \l__starray_tmpb_tl
\bool_new:N \l__starray_parser_OK_bool


\prg_new_conditional:Npnn \__starray_term_parse_end:w  #1 ] #2 \q_stop { TF}
  {
    \quark_if_nil:nTF {#2}
      { \prg_return_false: } %% syntax ERR
      {
        \tl_set:Nn \l__starray_parsed_idx_tl {#1}
        \prg_return_true:
      }
  }


\prg_new_conditional:Npnn \__starray_term_parse_aux:w  #1 [ \q_nil \q_stop { TF}
  {
    \__starray_term_parse_end:wTF  #1 ] \q_nil\q_stop
      {\prg_return_true:}
      {\prg_return_false:}
  }


\prg_new_conditional:Npnn \__starray_term_parse_begin:w #1 [ #2 \q_stop { TF}
  {
    \tl_set:Nn \l__starray_parsed_term_tl {#1}

    \quark_if_nil:nTF {#2}
      {               % no 'term' ref, just array_name (current/iter term)
        \tl_clear:N \l__starray_parsed_idx_tl
        \prg_return_true:
      }
      {
        \__starray_term_parse_aux:wTF #2 \q_stop
          {\prg_return_true:}
          {\prg_return_false:}
      }
  }


% TODO: verify #2 before going for #1 . . .
% TODO: if #2 isn't empty test for it return true/false
% TODO: if #2 is empty, test if #1 is valid, return true/false
\prg_new_conditional:Npnn \__starray_if_valid_idx:nn #1#2 {p, T, F, TF}
  {
    \prop_get:cnN {\l__starray_prefix_tl \l__starray_parsed_ref_tl _base_prop} {idx_hash} \l_tmpa_prop

    \tl_if_blank:nTF {#2}
      {
        \tl_put_right:Ne \l__starray_parsed_ref_tl
          {  _  \prop_item:Ne \l_tmpa_prop {#1} }
      }
      {
        \tl_put_right:Ne \l__starray_parsed_ref_tl
          {  _  \prop_item:Ne \l_tmpa_prop {#2} }
      }

    \prop_if_exist:cTF { \l__starray_prefix_tl \l__starray_parsed_ref_tl _term_prop }
      {\prg_return_true:}
      {\prg_return_false:}
  }

\prg_generate_conditional_variant:Nnn \__starray_if_valid_idx:nn {ee} {p, T, F, TF}

\cs_new:Npn \__starray_ref_parse:w #1 . #2 \q_stop
  {
    \tl_put_right:Ne \l__starray_parsed_tl {#1}

    \__starray_term_parse_begin:wTF #1 [ \q_nil \q_stop
      {                                    % syntax ok so far.
                                           % TODO: verify instance validity hash/index
                                           % vars: \l__starray_parsed_term_tl
                                           %       \l__starray_parsed_idx_tl
        \tl_put_right:Ne \l__starray_parsed_ref_tl { \l__starray_parser_aux_tl \l__starray_parsed_term_tl }
        \tl_put_right:Ne \l__starray_parsed_base_ref_tl { \l__starray_parser_aux_tl \l__starray_parsed_term_tl }
        \tl_set:Nn \l__starray_parser_aux_tl {.}

        \__starray_if_valid:eTF {\l__starray_prefix_tl \l__starray_parsed_ref_tl _base_prop}
          {
            \quark_if_nil:nTF {#2}
            {       % TODO: this is the last one
              \bool_if:NTF \l__starray_parser_no_idx_ending_bool
              {                                             % assuming it is to add a term...
                \tl_if_empty:NTF \l__starray_parsed_idx_tl
                { }       % done. correct
                {
                  \tl_set:Nn \l__starray_parser_errcode_tl {parser:1}
                  \bool_set_false:N \l__starray_parser_OK_bool
                } % err !
              }
              {    % TODO: assuming it is to set/get a property
                  % TODO: test the given idx (and not iter...)
                \__starray_if_valid_idx:eeTF
                  {
                    \int_use:N \prop_item:cn
                                {\l__starray_prefix_tl \l__starray_parsed_ref_tl _base_prop}
                                {iter}
                  }
                  {
                    \l__starray_parsed_idx_tl
                  }
                  { }      % done, finish, ok
                  {
                    \tl_set:Nn \l__starray_parser_errcode_tl {parser:2}
                    \bool_set_false:N \l__starray_parser_OK_bool
                  }
              }
            }
            {                       % TODO: there is more to be looked at
              \__starray_if_valid_idx:eeTF
                {
                  \int_use:N \prop_item:cn {\l__starray_prefix_tl \l__starray_parsed_ref_tl _base_prop} {iter}
                }
                {
                  \l__starray_parsed_idx_tl
                }
                {
                  \__starray_ref_parse:w #2 \q_stop
                }      % recurse next term
                {
                  \tl_set:Nn \l__starray_parser_errcode_tl {parser:3}
                  \bool_set_false:N \l__starray_parser_OK_bool
                }
            }
          }
          {
            \tl_set:Nn \l__starray_parser_errcode_tl {parser:4}
            \bool_set_false:N \l__starray_parser_OK_bool
          } % invalid/ref err.
      }
      {
        \tl_set:Nn \l__starray_parser_errcode_tl {parser:5}
        \bool_set_false:N \l__starray_parser_OK_bool
      } % syntax/ref err.
  }

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% parser 'true' returns:
%%%%                       \l__starray_parsed_ref_tl
%%%%                       \l__starray_parsed_base_ref_tl
%%%%                       \l__starray_parsed_root_ref_tl
%%%% parser 'false' returns:
%%%%                       \l__starray_parser_errcode_tl
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%

\prg_new_conditional:Npnn \__starray_parser:nn #1#2 {p, T, F, TF}
  {
    \bool_set_eq:NN \l__starray_parser_no_idx_ending_bool #1
    \bool_set_true:N \l__starray_parser_OK_bool

    \tl_clear:N \l__starray_parsed_tl
    \tl_clear:N \l__starray_parsed_ref_tl
    \tl_clear:N \l__starray_parsed_base_ref_tl
    \tl_clear:N \l__starray_parser_errcode_tl

    \tl_set:Nn \l__starray_parser_aux_tl {}

    \__starray_ref_parse:w #2 .\q_nil\q_stop

    \bool_if:NTF \l__starray_parser_OK_bool
      {
        \tl_set:Ne \l__starray_parsed_root_ref_tl
          { \__starray_get_root:w \l__starray_parsed_base_ref_tl .\q_nil\q_stop }
        \prg_return_true:
      }
      {
        \msg_warning:nnxxx {starray}{syntax / ref-syntax-err}
          {\l__starray_parser_errcode_tl} {#2} {\l__starray_parsed_tl}
        \prg_return_false:
      }
  }


\prg_new_conditional:Npnn \starray_term_syntax:n #1 {p, T, F, TF}
  {
    \__starray_parser:nnTF {\c_false_bool}{#1}
      {\prg_return_true:}
      {\prg_return_false:}
  }

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% \..show_def commands
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%


\cs_new:Npn \__starray_show_def_item:nnn #1#2#3
  {
    \tl_put_right:Nn \l__starray_tmpa_tl
    {
      \iow_newline: > #1 \use:nnn { ~ } { ~ } { ~ }
      \tl_to_str:n { {#2} }
      \use:nn { ~ } { ~ } => \use:nn { ~ } { ~ }
      \tl_to_str:n { {#3} }
    }
  }

\cs_new:Npn \__starray_show_def:nnnn #1#2#3#4
  {
    \tl_put_right:Nn \l__starray_tmpa_tl
    {
      \iow_newline: > #2
      \tl_to_str:n {{#4} ~ struct}
      \use:nn { ~ } { ~ } =>
    }

    \prop_get:cnc {\l__starray_prefix_tl #3#4 _def_prop} {def} {l__starray_tmp #4 _def_prop}

    \prop_get:cnc { \l__starray_prefix_tl #3#4 _def_prop } { @st_seq } {l__starray_tmp #1_#4 _seq }

    \prop_map_tokens:cn {l__starray_tmp #4 _def_prop} {\__starray_show_def_item:nnn {#2}}

    \seq_if_empty:cTF { l__starray_tmp #1_#4 _seq }
      {}
      {
        \seq_map_tokens:cn
        { l__starray_tmp #1_#4 _seq }
        { \__starray_show_def:nnnn { #1 A } { #2 \use:nnn { ~ } { ~ } { ~ }} { #3#4. }  }
      }
  }

\tl_new:N \l__starray_tmpa_tl

%%%%%%%%%%%%%%%
%%%%
%%%% \starray_show_def
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_show_def:n #1
  {
    \tl_clear:N \l__starray_tmpa_tl
    \__starray_show_def:nnnn {A}{}{}{#1}

    \msg_show:nnxxx {starray}{info / show}
      { show~def }
      { The~ starray~ <#1> ~is~defined~as~follow: }
      { \tl_use:N \l__starray_tmpa_tl }
  }

%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%
%%%%
%%%% \..show_terms commands
%%%%
%%%%
%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%


\cs_new:Npn \__starray_show_term_item:nnnnnn #1#2#3#4#5#6
  {
    \tl_put_right:Nn \l__starray_tmpa_tl
      {
        \iow_newline: > #2
        \tl_to_str:n { {#4[#5]} ~ (idx: ~ #6)}
        \use:nn { ~ } { ~ } =>
      }

    \prop_map_tokens:cn {\l__starray_prefix_tl #3 #4 _ #6 _term_prop} {\__starray_show_def_item:nnn {#2 }}

    \prop_get:cnN { \l__starray_prefix_tl #3 #4 _base_prop } { def_ref } \l_tmpa_tl

    \prop_get:cnc { \l__starray_prefix_tl \l_tmpa_tl _def_prop } { @st_seq } {l__starray_tmp #4_#6 _seq }

    \seq_if_empty:cTF { l__starray_tmp #4_#6 _seq }
      {}
      {
        \seq_map_tokens:cn
        { l__starray_tmp #4_#6 _seq }
        { \__starray_show_terms:nnen { #1 A } { #2 \use:nnn { ~ } { ~ } { ~ }} { #3  #4_#6. }  }
      }
  }



\cs_new:Npn \__starray_show_terms:nnnn #1#2#3#4
  {
    \prop_get:cnc {\l__starray_prefix_tl #3 #4 _base_prop} {idx_hash} {l__starray_tmp #1#4 _idx_prop}

    \prop_map_tokens:cn
      {l__starray_tmp #1#4 _idx_prop}
      {\__starray_show_term_item:nnnnnn {#1}{#2}{#3}{#4}}
  }

\cs_generate_variant:Nn \__starray_show_terms:nnnn {nnen}

%%%%%%%%%%%%%%%
%%%%
%%%% \starray_show_terms
%%%%
%%%%%%%%%%%%%%%

\cs_new:Npn \starray_show_terms:n #1
  {
    \tl_clear:N \l__starray_tmpa_tl
    \__starray_show_terms:nnnn {A}{}{}{#1}

    \msg_show:nnxxx {starray}{info / show}
      { show~terms }
      { The~ starray~ <#1> ~has~the~following~terms: }
      { \tl_use:N \l__starray_tmpa_tl }
  }

