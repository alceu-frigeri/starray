%%%==============================================================================
% WinEdt pragmas
% !Mode:: "TeX:EN"
% Default Compile engines:
% !TEX program = pdflatex
% !PDFTeXify ext =  --enable-etex  --restrict-write18
% !PDFLaTeX ext  =  --enable-etex  --restrict-write18
% !BIB program = none
%%%==============================================================================
%% Copyright 2023-present by Alceu Frigeri
%%
%% This work may be distributed and/or modified under the conditions of
%%
%% * The [LaTeX Project Public License](http://www.latex-project.org/lppl.txt),
%%   version 1.3c (or later), and/or
%% * The [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.html),
%%   version 3 (or later)
%%
%% This work has the LPPL maintenance status *maintained*.
%%
%% The Current Maintainer of this work is Alceu Frigeri
%%
%% This is version {2.0} {2026/02/02}
%%
%% The list of files that compose this work can be found in the README.md file at
%% https://ctan.org/pkg/starray
%%
%%%==============================================================================
\documentclass[10pt]{article}
\RequirePackage[verbose,a4paper,marginparwidth=27.5mm,top=2.5cm,bottom=1.5cm,hmargin={40mm,20mm},marginparsep=2.5mm,columnsep=10mm,asymmetric]{geometry}
%\RequirePackage[verbose,a4paper,marginparwidth=27.5mm,top=2.5cm,bottom=1.5cm,hmargin={45mm,25mm},marginparsep=2.5mm,columnsep=10mm,asymmetric]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[infograb,silence]{codedescribe}
\usepackage{starray}
\RequirePackage[inline]{enumitem}
\SetEnumitemKey{miditemsep}{parsep=0ex,itemsep=0.4ex}


\newcodekey{starray}{
  codeprefix={},resultprefix={},letter={@,_},
  texcs=[2]{starray_new,starray_if_exist,starray_if_valid,starray_def_prop,starray_def_struct,starray_def_from_keyval,starray_fix_terms,starray_new_term},
  texcs=[2]{starray_set_iter,starray_reset_iter,starray_next_iter,starray_set_iter_from_hash},
  texcs=[2]{starray_iterate_over},
  texcs=[2]{starray_set_prop,starray_gset_prop,starray_set_from_keyval,starray_gset_from_keyval},
  texcs=[2]{starray_get_prop,starray_if_in,starray_get_unique_id,starray_get_iter,starray_get_cnt},
  texcs=[2]{starray_term_parser},
  texcs=[2]{starray_parsed_get_prop,starray_parsed_if_in,starray_parsed_get_unique_id,starray_parsed_get_iter,starray_parsed_get_cnt},
  texcs=[2]{starray_uparsed_get_prop,starray_uparsed_if_in,starray_uparsed_get_unique_id,starray_uparsed_get_iter,starray_uparsed_get_cnt},
  texcs=[2]{starray_iparsed_get_prop,starray_iparsed_if_in,starray_iparsed_get_unique_id,starray_iparsed_get_iter,starray_iparsed_get_cnt},
%  keywd=[2]{oarg,arg,parg,xarg,meta,color},
%  keywd={codedescribe,codesyntax,codestore,tsremark},
  emph=[2]{struct}
  }


\RequirePackage[hidelinks,hypertexnames=false]{hyperref}
\begin{document}
\tstitle{
  author={Alceu Frigeri\footnote{\tsverb{https://github.com/alceu-frigeri/starray}}},
  date={\tsdate},
  title={The starray Package\break Version \PkgInfo{starray}{version}}
  }
  
\begin{typesetabstract}

This package implements vector like 'structures', alike 'C' and other programming languages. 
It's based on \tsobj[pkg]{expl3} and aimed at 'package writers', and not end users. The provided commands are similar the ones provided for property (or sequence, or token) lists. Most of the provided functions have a companion ``branching version''.

\end{typesetabstract}

\tableofcontents

\section{Introduction}
The main idea is to have an array like syntax when setting/recovering structured information, e.g. \tsmacro{\starray_get_prop:nn} {student[2].work[3].reviewer[4] , name} where ``student'' is the starray root, ``work'' is a sub-structure (an array in itself), ``reviewer'' is a sub-structure of ``work'' and so on, \tsobj[marg]{name} being a property of ``reviewer''. Moreover one can iterate over the structure, for instance \tsmacro{\starray_get_prop:nn}{student.work.reviewer,name} is also a possible reference in which one is using ``student's'', ``work's'' and ``reviewer's'' iterators.

Internally, a \tsobj[pkg]{starray} is stored as a collection of property lists. Each \tsobj[pkg]{starray} can contain a list of property pairs (key/value as in any \tsobj[pkg]{expl3} property lists) and a list of sub-structures. Each sub-structure, at it's turn, can also contain a list of property pairs and a list of sub-structures. 

The construction/definition of a \tsobj[pkg]{starray} can be done piecewise (a property/sub-structure a time) or with a keyval interface or both, either way, one has to first ``create a root starray'' (\tsmacro{\starray_new:n}{}), define it's elements (properties and sub-structures), then instantiate them ``as needed''. An instance of a \tsobj[pkg]{starray} (or one of it's sub-structures) is referred, in this text, as a ``term''.

Finally, almost all defined functions have a branching version, as per \tsobj[pkg]{expl3}: \tsobj[code]{T,F,TF} (note: no \tsobj{_p} variants, see below). For simplicity, in the text bellow only the \underline{\textsl{TF}} variant is described, as in \tsobj[code]{\starray_new:nTF}, keep in mind that all 3 variants are defined, e.g. \tsobj[code]{\starray_new:nT,\starray_new:nF,\starray_new:nTF}.

\begin{tsremark}[Note:]
 Could it be implemented with a single property list? It sure could, but at a cost: 
\begin{enumerate*}   \item complexity;    \item access time.   \end{enumerate*}
The current implementation, albeit also complex, tries to reach a balance between an inherent structure complexity, number of used/defined auxiliary property lists and access time.
\end{tsremark}

\begin{tsremark}[\color{red}Important:]
 \textsl{Expandability}, unfortunately most/all defined functions are not ``expandable'', in particular, most conditional/branching functions aren't, with just a few exceptions (marked with a star \ding{72}).
 
\end{tsremark}


\section{Package Options}\label{pack:options}
The package options (\tsobj[key]{key}\,=\tsobj[value]{value}) are:
\begin{describelist}{option}
%\describe{prefix}{(default: \tsobj[value]{\detokenize{l__starray_}} ). Set the \tsobj[key]{prefix} used when declaring the property lists associated with any \tsobj[pkg]{starray}.}

\describe{msg-err}
{By default, the \tsobj[pkg]{starray} package only generates ``warnings'', with \tsobj[option]{msg-err} one can choose which cases will generate ``package error'' messages. There are 3 message classes: 
  \begin{enumerate}[nosep]
    \item \tsobj[value]{strict} relates to \tsmacro{\starray_new:n}{} cases (\tsobj[pkg]{starray} creation);
    \item \tsobj[value]{syntax} relates to ``term syntax'' errors (student.work.reviewer in the above examples); and
    \item \tsobj[value]{reference} relates to cases whereas the syntax is correct but referring to a non-existent term or property.
  \end{enumerate}
   }

\begin{describelist*}{value}
\describe{none}{ (default) no package message will raise an error.}
\describe{strict}{ will raise an error on \tsobj[value]{strict} case alone.}
\describe{syntax}{ will raise an error on \tsobj[value]{strict} and \tsobj[value]{syntax} cases.}
\describe{reference}{ will raise an error on \tsobj[value]{strict}, \tsobj[value]{syntax} and \tsobj[value]{reference} cases.}
\describe{all}{ will raise an error on all cases.}
\end{describelist*}

\describe{msg-suppress}{ditto, to suppress classes of messages:}
\begin{describelist*}{value}
\describe{none}{ (default) no package message will be suppressed.}
\describe{reference}{ only \tsobj[value]{reference} level messages will be suppressed.}
\describe{syntax}{ \tsobj[value]{reference} and \tsobj[value]{syntax} level messages will be suppressed.}
\describe{strict}{ \tsobj[value]{reference}, \tsobj[value]{syntax} and \tsobj[value]{strict} level messages will be suppressed.}
\describe{all}{ all messages will be suppressed.}
\end{describelist*}

\describe{parsed check}{By default (false) the many \tsobj{\starray_parsed_} commands won't check if the last \tsobj{\starray_term_parser:} was successful. With this option, they will test it (with a performance hit) raising a warning/error accordantly.}
\describe{NN names}{Compatibility option. See \ref{parsed:user-var} for more details. Possible values are:}
\begin{describelist*}{value}
  \describe{none}{(default) None of the old \tsobj{...parsed..:NN..} functions will be defined.}
  \describe{no warnings}{The old \tsobj{...parsed..:NN..} functions will be defined. No warnings will be issued}
  \describe{strict}{The old \tsobj{...parsed..:NN..} functions will be defined, issuing a deprecation warning at each use.}
\end{describelist*}
\describe{iter cascade}{By default, since version 2.0, when setting the value of an iterator, none of the substructure's iterators will be affected. With this option set, all substructure's iterators will be reset to 1 (or zero), see \ref{pack:iter}.}
\end{describelist}

\section{Demo package(s)}
Given the inherent complexity of this package, one can find at \url{https://github.com/alceu-frigeri/starray/tree/main/demo} an example, \tsobj[pkg]{stdemo.sty}, package with its companion documentation \tsobj[pkg]{stdemo.pdf}. Since the aforementioned package, and documentation, are just an example of use, it doesn't make sense to add them to CTAN.

\section{Creating a starray}\label{pack:new}
\begin{codedescribe}{\starray_new:n,\starray_new:nTF}
\begin{codesyntax}%
\tsmacro{\starray_new:n}{starray}
\tsmacro{\starray_new:nTF}{starray,if-true,if-false}
\end{codesyntax}
Creates a new \tsobj[marg]{starray} or raises a warning  if the name is already taken. The declaration (and associated property lists) is global. The given name is referred (in this text) as the \tsobj[marg]{starray-root} or just \tsobj[marg]{root}. 
\end{codedescribe}
\begin{tsremark}
  A warning is raised (see \ref{pack:options}) if the name is already taken. The branching version doesn't raise any warning.
\end{tsremark}

\subsection{Conditionals}\label{conditionals:exist}
\begin{codedescribe}[code,EXP,new=2023/05/20,update=2024/03/28]{\starray_if_exist_p:n,\starray_if_exist:nTF,\starray_if_valid_p:n,\starray_if_valid:nTF}
\begin{codesyntax}%
\tsmacro{\starray_if_exist_p:n}{starray}
\tsmacro{\starray_if_exist:nTF}{starray,if-true,if-false}
\tsmacro{\starray_if_valid_p:n}{starray}
\tsmacro{\starray_if_valid:nTF}{starray,if-true,if-false}
\end{codesyntax}
\tsobj{\starray_if_exist:nTF} only tests if \tsobj[marg]{starray} (the base property) is defined. It doesn't verifies if it really is a  \tsobj[pkg]{starray}. \tsobj{\starray_if_valid:nTF} is functionally equivalent, since release 1.9. See \tsobj{\starray_term_parser:nTF}, section \ref{conditionals:terms}, for a more reliable validity test.
\end{codedescribe}
\begin{tsremark}
The predicate versions, \tsobj{_p}, expand to either \tsobj{\c_true_bool} or\break  \tsobj{\c_false_bool}
\end{tsremark}

\section{Defining and initialising a starray structure}\label{pack:def}

\begin{codedescribe}{\starray_def_prop:nnn,\starray_def_prop:nnnTF}
\begin{codesyntax}%
\tsmacro{\starray_def_prop:nnn}{starray-ref,prop-key,initial-value}
\tsmacro{\starray_def_prop:nnnTF}{starray-ref,prop-key,initial-value,if-true,if-false}
\end{codesyntax}
Adds an entry, \tsobj[marg]{prop-key}, to the \tsobj[marg]{starray-ref} (see \ref{pack:ref}) definition and set its initial value. If \tsobj[marg]{prop-key} is already present its initial value is updated. Both \tsobj[marg]{prop-key} and \tsobj[marg]{initial-value} may contain any \tsobj[marg]{balanced text}. \tsobj[marg]{prop-key} is an (\tsobj[pkg]{expl3}) property list \tsobj[marg]{key} meaning that category codes are ignored.

The definition/assignment of a \tsobj[marg]{prop-key} to a \tsobj[marg]{starray-ref} is global.
\end{codedescribe}

\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax/reference error. The branching version doesn't raise any warning.
\end{tsremark}

\begin{codedescribe}{\starray_def_structure:nn,\starray_def_structure:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_def_struct:nn}{starray-ref,struct-name}
\tsmacro{\starray_def_struct:nnTF}{starray-ref,struct-name,if-true,if-false}
\end{codesyntax}
Adds a sub-structure (a \tsobj[pkg]{starray} in itself) to \tsobj[marg]{starray-ref} (see \ref{pack:ref}). If \tsobj[marg]{struct-name} is already present nothing happens. The definition/assignment of a \tsobj[marg]{struct-name} to a \tsobj[marg]{starray-ref} is global.
\end{codedescribe}


\begin{tsremark}
Do not use a dot when defining a (sub-)structure name, it might seems to work but it will breaks further down (see \ref{pack:ref}).
\end{tsremark}


\begin{tsremark}[Note 2:]
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}

\begin{codedescribe}{\starray_def_from_keyval:nn,\starray_def_from_keyval:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_def_from_keyval:nn}{starray-ref,keyval-lst}
\tsmacro{\starray_def_from_keyval:nnTF}{starray-ref,keyval-lst,if-true,if-false}
\end{codesyntax}

Adds a set of \tsobj[marg]{keys} / \tsobj[marg]{values} and/or \tsobj[marg]{structures} to \tsobj[marg]{starray-ref} (see \ref{pack:ref}). The \tsobj[marg]{keyval-lst} is pretty straightforward, 
the construction \tsobj[key]{\tsobj[marg]{key} . struct} denotes a nested structure :
\end{codedescribe}

\begin{codestore}[keyval.demo]
\starray_def_from_keyval:nn {root.substructure} 
  {
    keyA = valA ,
    keyB = valB ,
    subZ . struct = 
      {
        keyZA = valZA ,
        keyZB = valZB ,
      }
    subY . struct =
      {
        keyYA = valYA ,
        keyYB = valYB ,
        subYYY . struct =
          {
            keyYYYa = valYYYa ,
            keyYYYb = valYYYb 
          }
      }
  }
\end{codestore}

\tscode*[starray]{keyval.demo}

The definitions/assignments  to \tsobj[marg]{starray-ref} are all global.

\begin{tsremark}
The non-branching version raises a warning (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning. Also note that, syntax errors on the \tsobj[marg]{keyval-lst} might raise low level (\TeX) errors.
\end{tsremark}

\subsection{Fixing an ill-instantiated starray}\label{pack:def-fix}

When instantiating (see \ref{pack:instantiate}) a \tsobj[pkg]{starray}, the associated structure will be constructed based on it's ``current definition'' (see \ref{pack:def}). A problem that might arise, when one extends the definition of an already instantiated \tsobj[pkg]{starray}  (better said, if one adds a sub-structure to it), is that a \textsl{quark loop} will issue (from \tsobj[pkg]{l3quark}). To avoid that  \textsl{quark loop} it is necessary to ``fix'' the structure of the already instantiated terms.

\begin{codedescribe}{\starray_fix_terms:n}
\begin{codesyntax}%
\tsmacro{\starray_fix_terms:n}{starray-ref}
\end{codesyntax}
The sole purpose of this function is to ``fix'' the already instantiated terms of a \tsobj[pkg]{starray}. Note, the reason this isn't automatically executed when adding a sub-structure, is that this is an expensive operation, because it has to craw over all the terms of an instantiated \tsobj[pkg]{starray} adding any missing sub-structure reference, but one doesn't need to run it ``right away'' it is possible to add a bunch of sub-structures and then run this just once.
\end{codedescribe}


\section{Instantiating starray Terms}\label{pack:instantiate}

\begin{codedescribe}{\starray_new_term:n,\starray_new_term:nn,\starray_new_term:nTF,\starray_new_term:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_new_term:n}{starray-ref}
\tsmacro{\starray_new_term:nn}{starray-ref,hash}
\tsmacro{\starray_new_term:nTF}{starray-ref,if-true,if-false}
\tsmacro{\starray_new_term:nnTF}{starray-ref,hash,if-true,if-false}
\end{codesyntax}
This create a new \textsl{term} (in fact a property list) of the (sub-)struture referenced by \tsobj[marg]{starray-ref}. Note that the newly created \textsl{term} will have all properties (key/values) as defined by the associated \tsmacro{\starray_prop_def:nn}{starray-ref}, with the respective ``initial values''. For instance, given the following 
\end{codedescribe}

\begin{codestore}[store-env=keyval.demo2]
\starray_new:n {st-root}

\starray_def_from_keyval:nn {st-root} 
  {
    keyA = valA ,
    keyB = valB ,
    subZ . struct = 
      {
        keyZA = valZA ,
        keyZB = valZB ,
      }
    subY . struct =
      {
        keyYA = valYA ,
        keyYB = valYB ,
        subYYY . struct =
          {
            keyYYYa = valYYYa ,
            keyYYYb = valYYYb 
          }
      }
  }
  
\starray_new_term:n {st-root}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subY}
\starray_new_term:nn {st-root}{hash-A}
\starray_new_term:n {st-root.subZ}
\end{codestore}

\tscode*[starray]{keyval.demo2}

One will have created 6 \textsl{terms}:
\begin{enumerate}[miditemsep]
\item 2 \tsobj[marg]{st-root} \textsl{terms}
  \begin{enumerate}[miditemsep]
  \item the first one with index 1 and
  \begin{enumerate}[miditemsep]
    \item 2 sub-structures \tsobj[marg]{subZ} (indexes 1 and 2)
    \item 1 sub-structure \tsobj[marg]{subY} (index 1)
  \end{enumerate}
  \item the second one with indexes 2 and ``hash-A'' and
  \begin{enumerate}[miditemsep]
    \item 1 sub-structure \tsobj[marg]{subZ} (index 1)
  \end{enumerate}
  \end{enumerate}
\end{enumerate}

Note that, in the above example, it was used the ``implicit'' indexing (aka. iterator, see \ref{pack:ref}). Also note that no \textsl{term}  \tsobj[marg]{subYYY} was created.
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}

\subsection{Referencing Terms}\label{pack:ref}

When typing a \tsobj[marg]{starray-ref} there are 3 cases to consider:
\begin{enumerate}[miditemsep]
  \item structure definition
  \item term instantiation
  \item getting/setting a property 
\end{enumerate}

The first case is the simplest one, in which, one (starting by \tsobj[marg]{starray-root} will use a construct like \tsobj[marg]{starray-root}.\tsobj[marg]{sub-struct}.\tsobj[marg]{sub-struct}\ldots 
For example, an equivalent construct to the one shown in \ref{pack:instantiate} :

\begin{codestore}[store-env=demo3]
\starray_new:n {st-root}

\starray_def_struct:nn {st-root}{subZ}

\starray_def_prop:nnn {st-root}{keyA}{valA}
\starray_def_prop:nnn {st-root}{keyB}{valB}

\starray_def_prop:nnn {st-root.subZ}{keyZA}{valZA}
\starray_def_prop:nnn {st-root.subZ}{keyZB}{valZB}

\starray_def_struct:nn {st-root}{subY}
\starray_def_prop:nnn {st-root.subY}{keyYA}{valYA}
\starray_def_prop:nnn {st-root.subY}{keyYB}{valYB}

\starray_def_struct:nn {st-root.subY}{subYYY}
\starray_def_prop:nnn {st-root.subY.subYYY}{keyYYYA}{valYYYA}
\starray_def_prop:nnn {st-root.subY.subYYY}{keyYYYB}{valYYYB}
  
\end{codestore}

\tscode*[starray]{demo3}

Note that, all it's needed in order to be able to use \tsobj[marg]{starray-root}.\tsobj[marg]{sub-A} is that \tsobj[marg]{sub-A} is an already declared sub-structure of \tsobj[marg]{starray-root}. The property definitions can be made in any order.

In all other cases, term instantiation, getting/setting a property, one has to address/reference a specific instance/term, implicitly (using iterators) or explicitly using indexes.
The general form, of a \tsobj[marg]{starray-ref}, is: \par
\tsobj[marg]{starray-root}\tsobj[oarg]{idx}.\tsobj[marg]{sub-A}\tsobj[oarg]{idxA}.\tsobj[marg]{sub-B}\tsobj[oarg]{idxB} \par
In the case of term instantiation the last \tsobj[marg]{sub-} cannot be indexed, after all one is creating a new term/index. Moreover, all \tsobj[oarg]{idx} are optional like:\par
\tsobj[marg]{starray-root}.\tsobj[marg]{sub-A}\tsobj[oarg]{idxA}.\tsobj[marg]{sub-B} \par
in which case, one is using the ``iterator'' of \tsobj[marg]{starray-root} and \tsobj[marg]{sub-B} (more later, but keep in mind the \tsobj[marg]{sub-B} iterator is the \tsobj[marg]{sub-B} associated with the \tsobj[marg]{sub-A}\tsobj[oarg]{idxA}).

Since one has to explicitly instantiate all (sub)terms of a starray, one can end with a highly asymmetric structure. Starting at the \tsobj[marg]{starray-root} one has a first counter (representing, indexing the root structure terms), then for all sub-strutures of \tsobj[marg]{starray-root} one will have an additional counter for every term of \tsobj[marg]{starray-root} !

So, for example:
\begin{codestore}[store-env=demo4]
\starray_new:n {st-root}
\starray_def_struct:nn {st-root}{subZ}
\starray_def_struct:nn {st-root}{subY}
\starray_def_struct:nn {st-root.subY}{subYYY}

\starray_new_term:n {st-root}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subY}
\starray_new_term:n {st-root.subY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root.subY}

\starray_new_term:n {st-root}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subY}
\end{codestore}

\tscode*[starray]{demo4}

One has a single \tsobj[marg]{st-root} iterator (pointing to one of the 3 \tsobj[marg]{st-root} terms), then 3 ``\tsobj[marg]{subZ} iterators'', in fact, one \tsobj[marg]{subZ} iterator for each \tsobj[marg]{st-root} term.
Likewise there are 3 ``\tsobj[marg]{subY} iterators'' and 4 (four) ``\tsobj[marg]{subYYY} iterators'' one for each instance of \tsobj[marg]{subY}.

Every time a new term is created/instantiated, the corresponding iterator will points to it, which allows the notation used in this last example, keep in mind that one could instead, using explicit indexes:

\begin{codestore}[store-env=demo5]
\starray_new:n {st-root}
\starray_def_struct:nn {st-root}{subZ}
\starray_def_struct:nn {st-root}{subY}
\starray_def_struct:nn {st-root.subY}{subYYY}

\starray_new_term:n {st-root}
\starray_new_term:n {st-root[1].subZ}
\starray_new_term:n {st-root[1].subZ}
\starray_new_term:n {st-root[1].subY}
\starray_new_term:n {st-root[1].subY}
\starray_new_term:n {st-root[1].subY[2].subYYY}
\starray_new_term:n {st-root[1].subY}

\starray_new_term:n {st-root}
\starray_new_term:n {st-root[2].subZ}
\starray_new_term:n {st-root[2].subZ}
\starray_new_term:n {st-root[2].subY}
\end{codestore}

\tscode*[starray]{demo5}

Finally, observe that, when creating a new term, one has the option to assign a ``hash'' to it, in which case that term can be referred to using an iterator, the explicit index or the hash:

\begin{codestore}[store-env=demo6]
\starray_new:n {st-root}
\starray_def_struct:nn {st-root}{subZ}
\starray_def_struct:nn {st-root}{subY}
\starray_def_struct:nn {st-root.subY}{subYYY}

\starray_new_term:nn {st-root}{hash-A}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root[1].subZ}
\starray_new_term:n {st-root[hash-A].subZ}
\end{codestore}
\tscode*[starray]{demo6}
 
Will create 3 \tsobj[marg]{subZ} terms associated with the first  \tsobj[marg]{st-root} term (index = 1).


\subsection{Iterators}\label{pack:iter}
In the following commands, since version 2.0, when setting/resetting/incrementing the  iterator of a (sub-)structure, only the given (sub-)structure iterator will be affected. With the package option \tsobj[option]{iter cascade} (see \ref{pack:options}) all ``descending'' iterators will also be reset to \tsobj[value,or]{1,0}.  All assignments to a structure's iterator are global.


\begin{codedescribe}[code,update=2026/02/01]{\starray_set_iter:nn,\starray_set_iter:nnTF,\starray_reset_iter:nn,\starray_reset_iter:nTF,\starray_next_iter:n,\starray_next_iter:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_set_iter:nn}{starray-ref,int-val}
\tsmacro{\starray_set_iter:nTF}{starray-ref,int-val,if-true,if-false}
\tsmacro{\starray_reset_iter:n}{starray-ref}
\tsmacro{\starray_reset_iter:nTF}{starray-ref,if-true,if-false}
\tsmacro{\starray_next_iter:n}{starray-ref}
\tsmacro{\starray_next_iter:nTF}{starray-ref,if-true,if-false}
\end{codesyntax}
Those functions allows to \tsmacro{set}{} an iterator to a given value, \tsobj[marg]{int-val}, \tsmacro{reset}{} it (i.e. assign 1 to it), or increase the iterator by one. An iterator might have a value between 1 and the number of instantiated terms. If the (sub-)structure wasn't instantiated, the iterator will be set to 0. The branching versions allows to catch those cases, like trying to set a value past its maximum, or a value smaller than one, otherwise values outside the valid range won't raise any warning/error.
\end{codedescribe}

%\begin{tsremark}[\color{red}Important:]
%Please observe that, when setting/resetting/incrementing the  iterator of a (sub-)structure, all ``descending'' iterators will also be reset.
%\end{tsremark}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}

In the following example, given:

\begin{codestore}[demo7]
\starray_new:n {st-root}
\starray_def_struct:nn {st-root}{subZ}
\starray_def_struct:nn {st-root}{subY}
\starray_def_struct:nn {st-root.subY}{subYYY}
\end{codestore}

\begin{codestore}[demo7]
\starray_new_term:n {st-root}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root.subY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subZ}
\starray_new_term:n {st-root.subY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root.subY}
\starray_new_term:n {st-root.subY.subYYY}
\starray_new_term:n {st-root.subY.subYYY}
\end{codestore}

\begin{codestore}[demo7]
\starray_set_prop:nnn {st-root.subY.subYYY}{key}{val}
\starray_set_prop:nnn {st-root[2].subY[2].subYYY[2]}{key}{val}

\starray_reset_iter:n {st-root[2].subY}

\starray_set_prop:nnn {st-root.subY.subYYY}{key}{val}
\starray_set_prop:nnn {st-root[2].subY[1].subYYY[1]}{key}{val}
\end{codestore}

\tscode*[starray,emph=[3]{starray_reset_iter},emph={starray_set_prop}]{demo7}
\tscode*[starray,emph=[3]{starray_reset_iter},emph={starray_set_prop}]{demo7}[2]
\tscode*[starray,emph=[3]{starray_reset_iter},emph={starray_set_prop}]{demo7}[3]

Before the reset \tsobj[marg]{st-root.subY.subYYY} was equivalent to \tsobj[marg]{st-root[2].subY[2].subYYY[2]}, given that each iterator was pointing to the ``last term'', since the reset was of the \tsobj[marg]{subY} iterator, only it  reset, and therefore \tsobj[marg]{st-root.subY.subYYY} was then equivalent to \tsobj[marg]{st-root[2].subY[1].subYYY[2]}.
\begin{tsremark}
  With the package option \tsobj[option]{iter cascade} all sub-structure's iterators will also be set/reset, meaning, in the above example, that after resetting the \tsobj[marg]{subY}, the iterator of \tsobj[marg]{subYYY} (it's only descendant) will also be reset, therefore \tsobj[marg]{st-root.subY.subYYY} would be equivalent to \tsobj[marg]{st-root[2].subY[1].subYYY[1]} in this case.
\end{tsremark}



\begin{codedescribe}[code,new=2023/11/04]{\starray_set_iter_from_hash:nn,\starray_set_iter_from_hash:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_set_iter_from_hash:nn}{starray-ref,hash}
\tsmacro{\starray_set_iter_from_hash:nnTF}{starray-ref,hash,if-true,if-false}
\end{codesyntax}
\tsmacro{\starray_set_iter_from_hash:nn}{starray-ref,hash} will set iter based on the \tsobj[meta]{hash} used when instantiating a term (see \ref{pack:instantiate} ).
\end{codedescribe}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error or invalid \tsobj[meta]{hash}. The branching version doesn't raise any warning.
\end{tsremark}


\begin{codedescribe}{\starray_get_iter:n,\starray_get_iter:nN,\starray_get_iter:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_get_iter:n}{starray-ref}
\tsmacro{\starray_get_iter:nN}{starray-ref,int-var}
\tsmacro{\starray_get_iter:nNTF}{starray-ref,int-var,if-true,if-false}
\end{codesyntax}
\tsmacro{\starray_get_iter:n}{starray-ref} will type in the current value of a given iterator, whilst the other two functions will save it's value in a integer variable (\tsobj[pkg]{expl3}).  The assignment is local.

\end{codedescribe}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}




\begin{codedescribe}{\starray_get_cnt:n,\starray_get_cnt:nN,\starray_get_cnt:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_get_cnt:n}{starray-ref}
\tsmacro{\starray_get_cnt:nN}{starray-ref,integer}
\tsmacro{\starray_get_cnt:nNTF}{starray-ref,integer,if-true,if-false}
\end{codesyntax}
\tsmacro{\starray_get_cnt:n}{starray-ref} will type in the current number of terms of a given (sub-)structure, whilst the other two functions will save it's value in a integer variable (\tsobj[pkg]{expl3}).  The assignment is local.

\end{codedescribe}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}

\subsubsection{Iterating Over}
\begin{codedescribe}[code,new=2023/11/04,update=2026/02/01]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_iterate_over:nn}{starray-ref,code}
\tsmacro{\starray_iterate_over:nnTF}{starray-ref,code,if-true,if-false}
\end{codesyntax}
\tsobj{\starray_iterate_over:nn} will reset the \tsobj[marg]{starray-ref} iterator, and then execute \tsobj[marg]{code} for each valid value of \tsobj{iter}. At the loop's end, the \tsobj[marg]{starray-ref} iterator will point to the last element of it. The \tsobj[marg]{if-true} is executed, at the loop's end if there is no syntax error, and the referenced structure was properly instantiated. Similarly \tsobj[marg]{if-false} is only execute if a syntax error is detected or the referenced structure wasn't properly instantiated. See \ref{parsed:iter-over} for a series of helper/companion commands when writing \tsobj[marg]{code}.
\end{codedescribe} \label{iterate-over}
\begin{tsremark}
\tsobj{\starray_iterate_over:nn} is recurse aware, and can be nested to recurse over sub-structures. Be aware, though,  that all iterators assignments are global. \end{tsremark}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error or the structure wasn't yet instantiated. The branching version doesn't raise any warning.
\end{tsremark}



\section{Changing and Recovering starray Properties}\label{pack:get/set}

\begin{codedescribe}{\starray_set_prop:nnn,\starray_set_prop:nnV,\starray_set_prop:nnnTF,\starray_set_prop:nnVTF,\starray_gset_prop:nnn,\starray_gset_prop:nnV,\starray_gset_prop:nnnTF,\starray_gset_prop:nnVTF}
\begin{codesyntax}%
\tsmacro{\starray_set_prop:nnn}{starray-ref,prop-key,value}
\tsmacro{\starray_set_prop:nnV}{starray-ref,prop-key,value}
\tsmacro{\starray_set_prop:nnnTF}{starray-ref,prop-key,value,if-true,if-false}
\tsmacro{\starray_set_prop:nnVTF}{starray-ref,prop-key,value,if-true,if-false}
\tsmacro{\starray_gset_prop:nnn}{starray-ref,prop-key,value}
\tsmacro{\starray_gset_prop:nnV}{starray-ref,prop-key,value}
\tsmacro{\starray_gset_prop:nnnTF}{starray-ref,prop-key,value,if-true,if-false}
\tsmacro{\starray_gset_prop:nnVTF}{starray-ref,prop-key,value,if-true,if-false}
\end{codesyntax}
Those are the functions that allow to (g)set (change) the value of a term's property. If the \tsobj[marg]{prop-key} isn't already present it will be added to that term, \tsobj[marg]{starray-ref}, only. The \tsobj[parg]{nnV} variants allow to save the value of a variable like a token list, clist list, etc...
\end{codedescribe}

\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}

\begin{codedescribe}{\starray_set_from_keyval:nn,\starray_set_from_keyval:nnTF,\starray_gset_from_keyval:nn,\starray_gset_from_keyval:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_set_from_keyval:nnn}{starray-ref,keyval-lst}
\tsmacro{\starray_set_from_keyval:nnnTF}{starray-ref,keyval-lst,if-true,if-false}
\tsmacro{\starray_gset_from_keyval:nnn}{starray-ref,keyval-lst}
\tsmacro{\starray_gset_from_keyval:nnnTF}{starray-ref,keyval-lst,if-true,if-false}
\end{codesyntax}
it is possible to set a collection of properties using a key/val syntax, similar to the one used to define a \tsobj[pkg]{starray} from keyvals (see \ref{pack:def}), with a few distinctions:
\begin{enumerate}
  \item when referring a (sub-)structure one can either explicitly use an index, or
  \item  implicitly use it's iterator 
  \item if a given key isn't already presented it will be added only to the given term
\end{enumerate}
 Note that, in the following example, TWO iterators are being used, the one for \tsobj[marg]{st-root} and then \tsobj[marg]{subY}.
\end{codedescribe}



\begin{codestore}[store-env=keyval.demo8]
\starray_set_from_keyval:nn {st-root} 
  {
    keyA = valA ,
    keyB = valB ,
    subZ[2] = 
      {
        keyZA = valZA ,
        keyZB = valZB ,
      }
    subY  =
      {
        keyYA = valYA ,
        keyYB = valYB ,
        subYYY[1] =
          {
            keyYYYa = valYYYa ,
            keyYYYb = valYYYb 
          }
      }
  }  
\end{codestore}

\tscode*[starray]{keyval.demo8}

Also note that the above example is fully equivalent to:

\begin{codestore}[store-env=keyval.demo9]
\starray_set_prop:nnn {st-root} {keyA} {valA}
\starray_set_prop:nnn {st-root} {keyB} {valB}
\starray_set_prop:nnn {st-root.subZ[2]} {keyZA} {valZA}
\starray_set_prop:nnn {st-root.subZ[2]} {keyZB} {valZB}
\starray_set_prop:nnn {st-root.subY} {keyYA} {valYA}
\starray_set_prop:nnn {st-root.subY} {keyYB} {valYB}
\starray_set_prop:nnn {st-root.subY.subYYY[1} {keyYYYa} {valYYYa}
\starray_set_prop:nnn {st-root.subY.subYYY[1} {keyYYYb} {valYYYb}
\end{codestore}

\tscode*[starray]{keyval.demo9}

\begin{codedescribe}{\starray_get_prop:nn,\starray_get_prop:nnN,\starray_get_prop:nnNTF}
\begin{codesyntax}%
\tsmacro{\starray_get_prop:nn}{starray-ref,key}
\tsmacro{\starray_get_prop:nnN}{starray-ref,key,tl-var}
\tsmacro{\starray_get_prop:nnNTF}{starray-ref,key,tl-var,if-true,if-false}
\end{codesyntax}
\tsmacro{\starray_get_prop:nn}{starray-ref,key} places the value of \tsobj[marg]{key} in the input stream. \break
\tsmacro{\starray_get_prop:nnN}{starray-ref,key,tl-var} recovers the value of \tsobj[marg]{key} and places it in \tsobj[marg]{tl-var} (a token list variable), this is specially useful in conjunction with \tsobj{\starray_set_prop:nnV}, whilst the \tsobj{\starray_get_prop:nnNTF} version branches accordly. The assignment is local.
\end{codedescribe}
\begin{tsremark}
In case of a syntax error, or \tsobj[marg]{key} doesn't exist, an empty value is left in the stream (or \tsobj[marg]{tl-var}).
\end{tsremark}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}


\section{Additional Commands and Conditionals}\label{conditionals:terms}

\begin{codedescribe}{\starray_if_in:nnTF}
\begin{codesyntax}%
\tsmacro{\starray_if_in:nnTF}{starray-ref,key,if-true,if-false}
\end{codesyntax}
The \tsmacro{\starray_if_in:nnTF}{starray-ref,key,\ldots,\ldots} tests if a given \tsobj[marg]{key} is present.
\end{codedescribe}

\begin{codedescribe}[code,new=2024/03/10]{\starray_get_unique_id:nN,\starray_get_unique_id:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_get_unique_id:nN}{starray-ref,tl-var}
\tsmacro{\starray_get_unique_id:nNTF}{starray-ref,tl-var,if-true,if-false}
\end{codesyntax}
Gets an `unique ID' for a given \tsobj[marg]{starray-ref} \emph{term}, it should help defining/creating uniquely identified auxiliary structures, like auxiliary property or sequence lists, since one can't (better said shouldn't, as per l3kernel) store an anonymous property/sequence list using V-expansion.  The assignment is local.

\end{codedescribe}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error. The branching version doesn't raise any warning.
\end{tsremark}

\section{Parsed Commands}\label{pack:parsed}
Since the parsing of a \tsobj[marg]{starray-ref} is a non-expandable and expensive operation, the commands below allow for some coding speed up (by avoiding parsing the same \tsobj[marg]{starray-ref} repeatedly) and offers expandable alternatives to a few commands.

The use pattern would be (1) to first parse the \tsobj[marg]{starray-ref} with either \tsobj[code,sep=or]{\starray_term_parser:n,\starray_term_parser:nN} and thereafter (2) use the many \tsobj[code,or]{\starray_parsed_,\starray_uparsed_} commands. 

Note that, there are three sets of  commands, one associated with \tsobj[code,sep=or]{\starray_term_parser:n,\starray_term_parser:nTF}{} (which relies on internal variables), another set associated with \tsobj[code,sep=or]{\starray_term_parser:nN,\starray_term_parser:nNTF}  (which allows to save many \tsobj[marg]{starray-ref} parsed terms), and lastly one associated with \tsobj[code,or]{\starray_iterate_over:nn} (see \ref{iterate-over}).


\subsection{Parsed Commands Based on Internal Variables}\label{parsed:internal}
\begin{codedescribe}[code,new=2023/05/20,update=2025/10/25]{\starray_term_parser:n,\starray_term_parser:nTF}
\begin{codesyntax}%
\tsmacro{\starray_term_parser:n}{starray-ref}
\tsmacro{\starray_term_parser:nTF}{starray-ref,if-true,if-false}
\end{codesyntax}
In case one needs to access the same term again and again, this will just parse  a \tsobj[marg]{starray-ref} reference once, and set interval variables so that commands like \tsobj{\starray_parsed_} can be used thereafter (avoiding having to slowly parse the same term over and over).
\end{codedescribe}
\begin{tsremark}
  The internal variables used are exclusive, no other command (besides these two), set them. This allows to ``parse a term'' and call other \tsobj{\starray_} commands before using the ``parsed term'' with one of the \tsobj{\starray_parsed_} commands.
\end{tsremark}
\begin{tsremark}[\color{red}Warning:]
While it allows for some code speedup, and enables some commands to be fully expandable, be aware that the internal variables will only be set correctly if, and only if, the \tsobj[marg]{starray-ref} is a valid term reference.
\end{tsremark}
\begin{tsremark}
  By default, the many associated \tsobj{\starray_parsed_} won't check the status of the last \tsobj{\starray_term_parser:n} operation. This can be changed with the package option \tsobj[option]{parsed check} (see \ref{pack:options}) in which case all associated \tsobj{\starray_parsed_} will then verify the status of the last operation and raise a warning/error.
\end{tsremark}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error, in which case the internal variables won't be set correctly. The branching version doesn't raise any warning.
\end{tsremark}
\begin{tsremark}
The \tsobj{\starray_term_syntax:n,\starray_term_syntax:nTF} have been deprecated (version 1.11), a warning is raised if a deprecated one is called.
\end{tsremark}

\begin{codedescribe}[code,EXP,new=2023/05/20]{\starray_parsed_if_in_p:n,\starray_parsed_if_in:nTF}
\begin{codesyntax}%
\tsmacro{\starray_parsed_if_in_p:nTF}{key}
\tsmacro{\starray_parsed_if_in:nTF}{key,if-true,if-false}
\end{codesyntax}
This will test if the given \tsobj[key]{key} is present in the ``last parsed term''. 
\end{codedescribe}
\begin{tsremark}
The predicate version, \tsobj{_p}, expands to either \tsobj{\c_true_bool} or \break \tsobj{\c_false_bool}.
\end{tsremark}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}


\begin{codedescribe}[code,EXP,new=2023/05/20]{\starray_parsed_get_iter:}
\begin{codesyntax}%
\tsobj{\starray_parsed_get_iter:}{}
\end{codesyntax}
\tsobj{\starray_parsed_get_iter:} will place in the current iterator's value,  using \tsobj{\int_use:N}, of the last parsed term in the input stream.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}

\begin{codedescribe}[code,new=2025/10/25]{\starray_parsed_get_iter:N,\starray_parsed_get_iter:NTF}
\begin{codesyntax}%
\tsmacro{\starray_parsed_get_iter:N}{int-var}
\tsmacro{\starray_parsed_get_iter:NTF}{int-var,if-true,if-false}
\end{codesyntax}
These will save the iterator’s value (of a parsed term) in a integer variable (\tsobj[pkg]{expl3}). The \tsobj[marg]{if-true,if-false} regards the status of the last \tsobj{\starray_term_parser:} command, iff the option \tsobj[option]{parsed check} (see \ref{pack:options}) is enable, otherwise it will always execute the \tsobj[marg]{if-true} branch.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}

\begin{codedescribe}[code,EXP,new=2023/05/20]{\starray_parsed_get_cnt:}
\begin{codesyntax}%
\tsobj{\starray_parsed_get_cnt:}{}
\end{codesyntax}
\tsobj{\starray_parsed_get_cnt:} will place the current number of terms, using \tsobj{\int_use:N}, of the last parsed term, in the input stream.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}

\begin{codedescribe}[code,new=2025/10/25]{\starray_parsed_get_cnt:N,\starray_parsed_get_cnt:NTF}
\begin{codesyntax}%
\tsmacro{\starray_get_cnt:N}{integer}
\tsmacro{\starray_get_cnt:NTF}{integer,if-true,if-false}
\end{codesyntax}
Similarly to \tsobj{\starray_get_cnt:nN,\starray_get_cnt:nNTF} these will save  the number of terms (of the last parsed term) in a integer variable (\tsobj[pkg]{expl3}). The \tsobj[marg]{if-true,if-false} regards the status of the last \tsobj{\starray_term_parser:} command, iff the option \tsobj[option]{parsed check} (see \ref{pack:options}) is enable, otherwise it will always execute the \tsobj[marg]{if-true} branch.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}




\begin{codedescribe}[code,EXP,new=2023/05/20]{\starray_parsed_get_prop:n}
\begin{codesyntax}%
\tsmacro{\starray_parsed_get_prop:n}{key}
\end{codesyntax}
\tsmacro{\starray_parsed_get_prop:n}{key} places the value of \tsobj[marg]{key}, if it exists, from the last parsed term, in the input stream. 
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}

\begin{codedescribe}[code,new=2025/10/25]{\starray_parsed_get_prop:nN,\starray_parsed_get_prop:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_parsed_get_prop:nN}{key,tl-var}
\tsmacro{\starray_parsed_get_prop:nNTF}{key,tl-var,if-true,if-false}
\end{codesyntax}
\tsmacro{\starray_parsed_get_prop:nN}{key,tl-val} stores the value of \tsobj[marg]{key}, if it exists, from the last parsed term. The \tsobj[marg]{if-false} branch is executed if \tsobj[marg]{key} doesn't exist or (if the option \tsobj[option]{parsed check}, see \ref{pack:options},  is enabled) if the last parser operation has failed.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}

\begin{codedescribe}[code,new=2025/10/25]{\starray_parsed_get_unique_id:nN,\starray_parsed_get_unique_id:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_parsed_get_unique_id:nN}{tl-var}
\tsmacro{\starray_parsed_get_unique_id:nNTF}{tl-var,if-true,if-false}
\end{codesyntax}
Gets an `unique ID' from the last parsed term. The \tsobj[marg]{if-true,if-false} regards the status of the last \tsobj{\starray_term_parser:} command, iff the option \tsobj[option]{parsed check} (see \ref{pack:options}) is enable, otherwise it will always execute the \tsobj[marg]{if-true} branch.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This can only be used after \tsobj{\starray_term_parser:n} and only makes sense (and returns a reliable/meaningful result) IF the last parser operation was successfully executed.
\end{tsremark}


\subsection{Parsed Commands Based on User Variables}\label{parsed:user-var}

Due to internal changes, since version 1.12, there is no longer the need to use two variables to save an `internal reference', though just reducing the signatures of the original \tsobj{_parsed_} commands by one N resulted in some name crashing which, unfortunately,  obliged a series of commands renaming, as follows: all commands related in this section now are named \tsobj{\starray_uparsed_} so they are completely distinct from those commands from the previous section, \ref{parsed:internal}. By default, only the new names are defined. Using the package option \tsobj[option]{NN names}, see \ref{pack:options}, the old command names get also defined. With \tsobj[option]{NN names = strict} the old commands will issue an warning pointing to the new names (this might result in low level errors if the commands are used in an expansion context). With \tsobj[option]{NN names = no warnings} the old commands won't issue any warning about their use.

\begin{codedescribe}[code,new=2023/11/28,update=2025/10/25,update=2025/12/08]{\starray_term_parser:nN,\starray_term_parser:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_term_parser:nN}{starray-ref,parsed-refA}
\tsmacro{\starray_term_parser:nNTF}{starray-ref,parsed-refA,if-true,if-false}
\end{codesyntax}
\tsobj[marg]{parsed-refA} (assumed to be a token list variable, \tsobj[meta]{tl-var}) will receive an `internal reference' that can be used in commands like \tsobj{\starray_uparsed_...:N} which expects such `reference'. The assignment is global.
\end{codedescribe}
\begin{tsremark}
Once correctly parsed, \tsobj[marg]{parsed-refA} can be used at 'any time' (by those few \tsobj{\starray_uparsed_...:N} associated commands).\end{tsremark}
\begin{tsremark}
A warning is raised (see \ref{pack:options}) in case of a \tsobj[marg]{starray-ref} syntax error (in which case \tsobj[marg]{parsed-refA} will not hold a valid value). The branching version doesn't raise any warning.
\end{tsremark}
\begin{tsremark}
 Commands \tsobj{\starray_term_parser:nNN,\starray_term_parser:nNNTF}, besides \tsobj{\starray_term_syntax:nNN,\starray_term_syntax:nNNTF}, have been deprecated (versions 1.11 and 1.12), a warning is raised if a deprecated one is called.
\end{tsremark}




\begin{codedescribe}[code,EXP,new=2023/11/28,update=2025/12/08]{\starray_uparsed_if_in_p:Nn,\starray_uparsed_if_in:NnTF}
\begin{codesyntax}%
\tsmacro{\starray_uparsed_if_in_p:nTF}{parsed-refA,key}
\tsmacro{\starray_uparsed_if_in:nTF}{parsed-refA,key,if-true,if-false}
\end{codesyntax}
This will test if the given \tsobj[key]{key} is present/associated with \tsobj[marg]{parsed-refA}.
\end{codedescribe}
\begin{tsremark}
The predicate version, \tsobj{_p}, expands to either \tsobj[code,sep=or]{\c_true_bool,\c_false_bool}.
\end{tsremark}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}


\begin{codedescribe}[code,EXP,new=2023/11/28,update=2025/12/08]{\starray_uparsed_get_iter:N}
\begin{codesyntax}%
\tsmacro{\starray_uparsed_get_iter:N}{parsed-refA}
\end{codesyntax}
\tsobj{\starray_uparsed_get_iter:} will place in the current iterator's value associated with \tsobj[marg]{parsed-refA},  using \tsobj{\int_use:N}, in the input stream.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}

\begin{codedescribe}[code,new=2025/10/25,update=2025/12/08]{\starray_uparsed_get_iter:NN,\starray_uparsed_get_iter:NNTF}
\begin{codesyntax}%
\tsmacro{\starray_uparsed_get_iter:NN}{parsed-refA,int-var}
\tsmacro{\starray_uparsed_get_iter:NNTF}{parsed-refA,int-var,if-true,if-false}
\end{codesyntax}
These will save the iterator’s value  in a \tsobj[marg]{int-var}. The  \tsobj{\starray_uparsed_get_iter:NNTF} is  for symmetry only (with other commands), it will always execute the  \tsobj[marg]{if-true}.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}



\begin{codedescribe}[code,EXP,new=2023/11/28,update=2025/12/08]{\starray_uparsed_get_cnt:N}
\begin{codesyntax}%
\tsmacro{\starray_uparsed_get_cnt:N}{parsed-refA}
\end{codesyntax}
\tsobj{\starray_uparsed_get_cnt:} will place in the current number of terms associated with \tsobj[marg]{parsed-refA},  using \tsobj{\int_use:N}, in the input stream.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}

\begin{codedescribe}[code,new=2025/10/25,update=2025/12/08]{\starray_uparsed_get_cnt:NN,\starray_uparsed_get_cnt:NNTF}
\begin{codesyntax}%
\tsmacro{\starray_get_cnt:NN}{parsed-refA,int-var}
\tsmacro{\starray_get_cnt:NNTF}{parsed-refA,int-var,if-true,if-false}
\end{codesyntax}
Similarly to \tsobj{\starray_get_cnt:nN,\starray_get_cnt:nNTF} these will save  the number of terms in \tsobj[marg]{int-var}.  The  \tsobj{\starray_uparsed_get_cnt:NNTF} is  for symmetry only (with other commands), it will always execute the  \tsobj[marg]{if-true}.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}



\begin{codedescribe}[code,EXP,new=2023/11/28,update=2025/12/08]{\starray_uparsed_get_prop:Nn}
\begin{codesyntax}%
\tsmacro{\starray_uparsed_get_prop:Nn}{parsed-refA,key}
\end{codesyntax}
\tsobj{\starray_uparsed_get_prop:Nn} places the value of \tsobj[marg]{key}, if it exists, associated with \tsobj[marg]{parsed-refA}.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}


\begin{codedescribe}[code,new=2025/10/25,update=2025/12/08]{\starray_uparsed_get_prop:NnN,\starray_uparsed_get_prop:NnNTF}
\begin{codesyntax}%
\tsmacro{\starray_uparsed_get_prop:NnN}{parsed-refA,key,tl-var}
\tsmacro{\starray_uparsed_get_prop:NnNTF}{parsed-refA,key,tl-var,if-true,if-false}
\end{codesyntax}
\tsmacro{\starray_uparsed_get_prop:NnN}{key,tl-val} stores the value of \tsobj[marg]{key}, if it exists, from the parsed term. 
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}

\begin{codedescribe}[code,new=2025/10/25,update=2025/12/08]{\starray_uparsed_get_unique_id:NN,\starray_uparsed_get_unique_id:NNTF}
\begin{codesyntax}%
\tsmacro{\starray_uparsed_get_unique_id:NN}{parsed-refA,tl-var}
\tsmacro{\starray_uparsed_get_unique_id:NNTF}{parsed-refA,tl-var,if-true,if-false}
\end{codesyntax}
Gets an `unique ID' from the last parsed term.   The  \tsobj{\starray_uparsed_get_unique_id:NNTF} is  for symmetry only (with other commands), it will always execute the  \tsobj[marg]{if-true}.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
\tsobj[marg]{parsed-refA} should be the value returned by  \tsobj{\starray_term_parser:nN}.
\end{tsremark}

\subsubsection{Deprecation Equivalence List}
Bellow follows a complete list of all deprecated names and their corresponding new names. Note each command signature (one N shorter).
\begin{describelist*}[60mm]{code}
  \describe{Deprecated}{\tsobj{New}}
  \describe{\starray_term_parser:nNN}            {\tsobj{\starray_term_parser:nN}}
  \describe{\starray_term_parser:nNNTF}          {\tsobj{\starray_term_parser:nNTF}}
  \describe{\starray_parsed_if_in_p:NNn}         {\tsobj{\starray_uparsed_if_in_p:Nn}}
  \describe{\starray_parsed_if_in:NNnTF}         {\tsobj{\starray_uparsed_if_in:NnTF}}
  \describe{\starray_parsed_get_iter:NN}         {\tsobj{\starray_uparsed_get_iter:N}}
  \describe{\starray_parsed_get_iter:NNN}        {\tsobj{\starray_uparsed_get_iter:NN}}
  \describe{\starray_parsed_get_iter:NNNTF}      {\tsobj{\starray_uparsed_get_iter:NNTF}}
  \describe{\starray_parsed_get_cnt:NN}          {\tsobj{\starray_uparsed_get_cnt:N}}
  \describe{\starray_parsed_get_cnt:NNN}         {\tsobj{\starray_uparsed_get_cnt:NN}}
  \describe{\starray_parsed_get_cnt:NNNTF}       {\tsobj{\starray_uparsed_get_cnt:NNTF}}
  \describe{\starray_parsed_get_prop:NNn}        {\tsobj{\starray_uparsed_get_prop:Nn}}
  \describe{\starray_parsed_get_prop:NNnN}       {\tsobj{\starray_uparsed_get_prop:NnN}}
  \describe{\starray_parsed_get_prop:NNnNTF}     {\tsobj{\starray_uparsed_get_prop:NnNTF}}
  \describe{\starray_parsed_get_unique_id:NNN}   {\tsobj{\starray_uparsed_get_unique_id:NN}}
  \describe{\starray_parsed_get_unique_id:NNNTF} {\tsobj{\starray_uparsed_get_unique_id:NNTF}}
\end{describelist*}


\subsection{Parsed Commands on Iterate Over}\label{parsed:iter-over}
When iterating over a \tsobj[marg]{starray-ref}, see \ref{iterate-over}, internal variables are set pointing the current (iterated over) starray term: This removes the need, for instance, to execute \tsobj{\starray_term_parser:n} before using some `parsed' commands (previous sections). The following commands can be used in combination with the ones from \ref{parsed:internal} and \ref{parsed:user-var}.

Observe that, in case of nested \tsobj{\starray_iterate_over:nn}, the \tsobj{_iparsed_} commands always refer to the immediate \tsobj{\starray_iterate_over:nn}, meaning that, in `case A' below, \tsobj[key]{key-Aa} is a key of the starray \tsobj[marg]{st-A} (\tsobj[marg]{st-A[iter st-A]}), whilst (case B), \tsobj[key]{key-Xa} is a key of the starray \tsobj[marg]{st-A.sub-X} (better said: \tsobj[marg]{st-A[iter st-A].sub-X[iter sub-X]}

\begin{codestore}[nested-iter]
  \starray_iterate_over:nn {st-A}
    {
      ... \starray_iparsed_get_prop:n {key-Aa}  %% case A
      
      \starray_iterate_over:NN {st-A.sub-X}
        {
          ... \starray_iparsed_get_prop:n {key-Xa}  %% case B
        }
    }
\end{codestore}
\tscode*[starray]{nested-iter}

\begin{codedescribe}[code,EXP,new=2026/02/01]{\starray_iparsed_if_in_p:n,\starray_iparsed_if_in:nTF}
\begin{codesyntax}%
\tsmacro{\starray_iparsed_if_in_p:nTF}{key}
\tsmacro{\starray_iparsed_if_in:nTF}{key,if-true,if-false}
\end{codesyntax}
This will test if the given \tsobj[key]{key} is present in the current, iterated over, term. 
\end{codedescribe}
\begin{tsremark}
The predicate version, \tsobj{_p}, expands to either \tsobj{\c_true_bool} or \break \tsobj{\c_false_bool}.
\end{tsremark}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}


\begin{codedescribe}[code,EXP,new=2026/02/01]{\starray_iparsed_get_iter:}
\begin{codesyntax}%
\tsobj{\starray_iparsed_get_iter:}{}
\end{codesyntax}
\tsobj{\starray_iparsed_get_iter:} will place in the current iterator's value,  using \tsobj{\int_use:N}, of the current, iterated over, term in the input stream.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}

\begin{codedescribe}[code,new=2026/02/01]{\starray_iparsed_get_iter:N,\starray_iparsed_get_iter:NTF}
\begin{codesyntax}%
\tsmacro{\starray_iparsed_get_iter:N}{int-var}
\tsmacro{\starray_iparsed_get_iter:NTF}{int-var,if-true,if-false}
\end{codesyntax}
These will save the iterator’s value (of a parsed term) in a integer variable (\tsobj[pkg]{expl3}). The \tsobj[marg]{if-true,if-false} regards the status of the last \tsobj{\starray_term_parser:} command, iff the option \tsobj[option]{parsed check} (see \ref{pack:options}) is enable, otherwise it will always execute the \tsobj[marg]{if-true} branch.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}

\begin{codedescribe}[code,EXP,new=2026/02/01]{\starray_iparsed_get_cnt:}
\begin{codesyntax}%
\tsobj{\starray_iparsed_get_cnt:}{}
\end{codesyntax}
\tsobj{\starray_iparsed_get_cnt:} will place the current number of terms, using \tsobj{\int_use:N}, of the current, iterated over, term, in the input stream.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}

\begin{codedescribe}[code,new=2026/02/01]{\starray_iparsed_get_cnt:N,\starray_iparsed_get_cnt:NTF}
\begin{codesyntax}%
\tsmacro{\starray_get_cnt:N}{integer}
\tsmacro{\starray_get_cnt:NTF}{integer,if-true,if-false}
\end{codesyntax}
Similarly to \tsobj{\starray_get_cnt:nN,\starray_get_cnt:nNTF} these will save  the number of terms (of the current, iterated over, term) in a integer variable (\tsobj[pkg]{expl3}). The \tsobj[marg]{if-true,if-false} regards the status of the last \tsobj{\starray_term_parser:} command, iff the option \tsobj[option]{parsed check} (see \ref{pack:options}) is enable, otherwise it will always execute the \tsobj[marg]{if-true} branch.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}




\begin{codedescribe}[code,EXP,new=2026/02/01]{\starray_iparsed_get_prop:n}
\begin{codesyntax}%
\tsmacro{\starray_iparsed_get_prop:n}{key}
\end{codesyntax}
\tsmacro{\starray_iparsed_get_prop:n}{key} places the value of \tsobj[marg]{key}, if it exists, from the current, iterated over, term, in the input stream. 
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}

\begin{codedescribe}[code,new=2026/02/01]{\starray_iparsed_get_prop:nN,\starray_iparsed_get_prop:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_iparsed_get_prop:nN}{key,tl-var}
\tsmacro{\starray_iparsed_get_prop:nNTF}{key,tl-var,if-true,if-false}
\end{codesyntax}
\tsmacro{\starray_iparsed_get_prop:nN}{key,tl-val} stores the value of \tsobj[marg]{key}, if it exists, from the current, iterated over, term. The \tsobj[marg]{if-false} branch is executed if \tsobj[marg]{key} doesn't exist or (if the option \tsobj[option]{parsed check}, see \ref{pack:options},  is enabled) if the last parser operation has failed.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}

\begin{codedescribe}[code,new=2026/02/01]{\starray_iparsed_get_unique_id:nN,\starray_iparsed_get_unique_id:nNTF}
\begin{codesyntax}%
\tsmacro{\starray_iparsed_get_unique_id:nN}{tl-var}
\tsmacro{\starray_iparsed_get_unique_id:nNTF}{tl-var,if-true,if-false}
\end{codesyntax}
Gets an `unique ID' from the current, iterated over, term. The \tsobj[marg]{if-true,if-false} regards the status of the last \tsobj{\starray_term_parser:} command, iff the option \tsobj[option]{parsed check} (see \ref{pack:options}) is enable, otherwise it will always execute the \tsobj[marg]{if-true} branch.
\end{codedescribe}
\begin{tsremark}[\color{red}Warning:]
This should only be used in the \tsobj[marg]{code} part of \tsobj[code,or]{\starray_iterate_over:nn,\starray_iterate_over:nnTF}.
\end{tsremark}



\section{Showing (debugging) starrays }\label{pack:show}

\begin{codedescribe}{\starray_show_def:n,\starray_show_def_in_text:n}
\begin{codesyntax}%
\tsmacro{\starray_show_def:n}{starray-ref}
\tsmacro{\starray_show_def_in_text:n}{starray-ref}
\end{codesyntax}
Displays the \tsobj[marg]{starray} structure definition and initial property values in the terminal or directly in text.
\end{codedescribe}


\begin{codedescribe}{\starray_show_terms:n,\starray_show_terms_in_text:n}
\begin{codesyntax}%
\tsmacro{\starray_show_terms:n}{starray-ref}
\tsmacro{\starray_show_terms_in_text:n}{starray-ref}
\end{codesyntax}
Displays the \tsobj[marg]{starray} instantiated terms and current  property values in the terminal or directly in text.
\end{codedescribe}


\end{document}
